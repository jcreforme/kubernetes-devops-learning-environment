# 8. Practice

## ğŸ¯ Learning Objectives
- [ ] Deploy a chart from scratch
- [ ] Modify values and perform upgrades  
- [ ] Practice rollback scenarios
- [ ] Master the complete Helm workflow
- [ ] Build confidence with real-world scenarios

## ğŸš€ Practice Scenario 1: Complete Application Lifecycle

### Step 1: Deploy a Chart
```bash
# Add the bitnami repository
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo update

# Deploy nginx application
helm install my-nginx bitnami/nginx `
  --set replicaCount=2 `
  --set service.type=NodePort

# Get the NodePort and IP (PowerShell version)
$NODE_PORT = kubectl get --namespace default -o jsonpath="{.spec.ports[0].nodePort}" services my-nginx
$NODE_IP = kubectl get nodes --namespace default -o jsonpath="{.items[0].status.addresses[0].address}"
Write-Host "http://${NODE_IP}:${NODE_PORT}"


# Verify deployment
helm status my-nginx
kubectl get pods -l app.kubernetes.io/instance=my-nginx
```

### Step 2: Modify Values and Upgrade
```powershell
# Create custom values file (PowerShell version)
@'
replicaCount: 3
image:
  tag: "1.26.0"
service:
  type: LoadBalancer
  port: 80
resources:
  limits:
    cpu: 300m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 128Mi
ingress:
  enabled: true
  hostname: my-nginx.local
'@ | Out-File -FilePath custom-values.yaml -Encoding UTF8

# Test upgrade with dry-run first
helm upgrade my-nginx bitnami/nginx `
  -f custom-values.yaml `
  --dry-run --debug

# Apply the upgrade
helm upgrade my-nginx bitnami/nginx `
  -f custom-values.yaml `
  --wait

# Verify upgrade
helm get values my-nginx --all
kubectl get pods -l app.kubernetes.io/instance=my-nginx
```

### Step 3: Simulate Problem and Rollback
```bash
# Simulate a problematic upgrade
helm upgrade my-nginx bitnami/nginx \
  --set image.tag=invalid-tag \
  --set replicaCount=10

# Check status (should show issues)
helm status my-nginx
kubectl get pods -l app.kubernetes.io/instance=my-nginx

# View history
helm history my-nginx

# Rollback to previous working version
helm rollback my-nginx --wait

# Verify rollback
helm status my-nginx
kubectl get pods -l app.kubernetes.io/instance=my-nginx
```

## ğŸ› ï¸ Practice Scenario 2: Multi-Environment Deployment

### Environment Setup
```bash
# Create namespace for different environments
kubectl create namespace development
kubectl create namespace staging
kubectl create namespace production
```

### Development Environment
```bash
# Create dev-values.yaml
cat > dev-values.yaml << EOF
replicaCount: 1
image:
  repository: nginx
  tag: "1.25.3"
  pullPolicy: Always
service:
  type: NodePort
resources:
  limits:
    cpu: 200m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 128Mi
env:
  - name: ENVIRONMENT
    value: "development"
  - name: DEBUG
    value: "true"
EOF

# Deploy to development
helm install dev-app bitnami/nginx \
  -f dev-values.yaml \
  --namespace development
```

### Staging Environment
```bash
# Create staging-values.yaml
cat > staging-values.yaml << EOF
replicaCount: 2
image:
  repository: nginx
  tag: "1.25.3"
  pullPolicy: IfNotPresent
service:
  type: ClusterIP
resources:
  limits:
    cpu: 300m
    memory: 512Mi
  requests:
    cpu: 150m
    memory: 256Mi
env:
  - name: ENVIRONMENT
    value: "staging"
  - name: DEBUG
    value: "false"
EOF

# Deploy to staging
helm install staging-app bitnami/nginx \
  -f staging-values.yaml \
  --namespace staging
```

### Production Environment
```bash
# Create prod-values.yaml
cat > prod-values.yaml << EOF
replicaCount: 3
image:
  repository: nginx
  tag: "1.25.3"
  pullPolicy: IfNotPresent
service:
  type: LoadBalancer
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi
env:
  - name: ENVIRONMENT
    value: "production"
  - name: DEBUG
    value: "false"
securityContext:
  runAsNonRoot: true
  runAsUser: 1001
EOF

# Deploy to production
helm install prod-app bitnami/nginx \
  -f prod-values.yaml \
  --namespace production
```

### Environment Comparison
```bash
# Compare deployments across environments
echo "=== Development ==="
helm get values dev-app --namespace development

echo "=== Staging ==="
helm get values staging-app --namespace staging

echo "=== Production ==="
helm get values prod-app --namespace production

# Check resource usage
kubectl top pods --namespace development
kubectl top pods --namespace staging
kubectl top pods --namespace production
```

## ğŸ”„ Practice Scenario 3: Configuration Management

### Base Configuration
```bash
# Create base-values.yaml (common to all environments)
cat > base-values.yaml << EOF
image:
  repository: nginx
  pullPolicy: IfNotPresent
service:
  port: 80
  targetPort: 8080
livenessProbe:
  enabled: true
  initialDelaySeconds: 30
  periodSeconds: 10
readinessProbe:
  enabled: true
  initialDelaySeconds: 5
  periodSeconds: 5
EOF
```

### Environment-Specific Overrides
```bash
# Create environment-specific files
cat > env-dev.yaml << EOF
replicaCount: 1
resources:
  limits:
    cpu: 200m
    memory: 256Mi
service:
  type: NodePort
EOF

cat > env-prod.yaml << EOF
replicaCount: 3
resources:
  limits:
    cpu: 500m
    memory: 512Mi
service:
  type: LoadBalancer
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
EOF

# Deploy with multiple values files
helm install config-app bitnami/nginx \
  -f base-values.yaml \
  -f env-prod.yaml \
  --namespace production
```

## ğŸ“Š Practice Scenario 4: Monitoring and Troubleshooting

### Deploy with Monitoring
```bash
# Create monitoring-values.yaml
cat > monitoring-values.yaml << EOF
replicaCount: 2
metrics:
  enabled: true
  serviceMonitor:
    enabled: true
resources:
  limits:
    cpu: 300m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 128Mi
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "9113"
  prometheus.io/path: "/metrics"
EOF

# Deploy application
helm install monitored-app bitnami/nginx \
  -f monitoring-values.yaml
```

### Troubleshooting Practice
```bash
# Simulate various issues for troubleshooting practice

# 1. Resource constraints
helm upgrade monitored-app bitnami/nginx \
  --set resources.limits.cpu=50m \
  --set resources.limits.memory=64Mi

# Check pod status
kubectl get pods -l app.kubernetes.io/instance=monitored-app
kubectl describe pods -l app.kubernetes.io/instance=monitored-app

# 2. Invalid image tag
helm upgrade monitored-app bitnami/nginx \
  --set image.tag=nonexistent-tag

# Check events
kubectl get events --sort-by=.metadata.creationTimestamp

# 3. Port conflicts
helm upgrade monitored-app bitnami/nginx \
  --set service.port=99999

# Troubleshoot and fix each issue
helm rollback monitored-app
```

## ğŸ§ª Practice Scenario 5: Advanced Operations

### Blue-Green Deployment Simulation
```bash
# Deploy blue version
helm install app-blue bitnami/nginx \
  --set 'labels.version=blue' \
  --set replicaCount=3 \
  --set 'podLabels.version=blue'

# Deploy green version
helm install app-green bitnami/nginx \
  --set 'labels.version=green' \
  --set replicaCount=3 \
  --set 'podLabels.version=green' \
  --set image.tag=1.26.0

# Create service to switch between versions
cat > switch-service.yaml << EOF
apiVersion: v1
kind: Service
metadata:
  name: app-switch-service
spec:
  selector:
    version: blue
  ports:
    - port: 80
      targetPort: 8080
  type: LoadBalancer
EOF

kubectl apply -f switch-service.yaml

# Switch traffic to green
kubectl patch service app-switch-service -p '{"spec":{"selector":{"version":"green"}}}'
```

### Canary Deployment
```bash
# Deploy stable version (90% traffic)
helm install app-stable bitnami/nginx \
  --set replicaCount=9 \
  --set 'labels.version=stable'

# Deploy canary version (10% traffic)
helm install app-canary bitnami/nginx \
  --set replicaCount=1 \
  --set 'labels.version=canary' \
  --set image.tag=1.26.0

# Monitor canary metrics and gradually increase traffic
helm upgrade app-canary bitnami/nginx \
  --set replicaCount=2

helm upgrade app-stable bitnami/nginx \
  --set replicaCount=8
```

## ğŸ”§ Practice Scenario 6: Automation and Scripting

### Deployment Automation Script
```bash
#!/bin/bash
# deploy-app.sh

APP_NAME=$1
ENVIRONMENT=$2
CHART_VERSION=${3:-latest}

if [ -z "$APP_NAME" ] || [ -z "$ENVIRONMENT" ]; then
  echo "Usage: $0 <app-name> <environment> [chart-version]"
  exit 1
fi

echo "ğŸš€ Deploying $APP_NAME to $ENVIRONMENT"

# Validate environment
case $ENVIRONMENT in
  "dev"|"staging"|"prod")
    echo "âœ… Valid environment: $ENVIRONMENT"
    ;;
  *)
    echo "âŒ Invalid environment. Use: dev, staging, or prod"
    exit 1
    ;;
esac

# Set environment-specific values
VALUES_FILE="values-${ENVIRONMENT}.yaml"
NAMESPACE="${ENVIRONMENT}"

# Create namespace if it doesn't exist
kubectl create namespace $NAMESPACE 2>/dev/null || true

# Perform dry-run first
echo "ğŸ” Performing dry-run validation..."
if ! helm upgrade --install $APP_NAME bitnami/nginx \
    -f $VALUES_FILE \
    --namespace $NAMESPACE \
    --version $CHART_VERSION \
    --dry-run > /dev/null 2>&1; then
  echo "âŒ Dry-run validation failed"
  exit 1
fi

# Deploy application
echo "ğŸ“¦ Deploying application..."
helm upgrade --install $APP_NAME bitnami/nginx \
  -f $VALUES_FILE \
  --namespace $NAMESPACE \
  --version $CHART_VERSION \
  --wait \
  --timeout 5m

if [ $? -eq 0 ]; then
  echo "âœ… Deployment successful"
  
  # Show deployment status
  helm status $APP_NAME --namespace $NAMESPACE
  kubectl get pods -l app.kubernetes.io/instance=$APP_NAME -n $NAMESPACE
else
  echo "âŒ Deployment failed"
  exit 1
fi
```

### Health Check Script
```bash
#!/bin/bash
# health-check.sh

RELEASE_NAME=$1
NAMESPACE=${2:-default}

if [ -z "$RELEASE_NAME" ]; then
  echo "Usage: $0 <release-name> [namespace]"
  exit 1
fi

echo "ğŸ¥ Health check for $RELEASE_NAME in $NAMESPACE"

# Check Helm release status
echo "ğŸ“Š Helm release status:"
helm status $RELEASE_NAME --namespace $NAMESPACE

# Check pod status
echo "ğŸ” Pod status:"
kubectl get pods -l app.kubernetes.io/instance=$RELEASE_NAME -n $NAMESPACE

# Check service status
echo "ğŸŒ Service status:"
kubectl get services -l app.kubernetes.io/instance=$RELEASE_NAME -n $NAMESPACE

# Check endpoints
echo "ğŸ¯ Endpoint status:"
kubectl get endpoints -l app.kubernetes.io/instance=$RELEASE_NAME -n $NAMESPACE

# Check events for any issues
echo "ğŸ“‹ Recent events:"
kubectl get events --namespace $NAMESPACE --field-selector involvedObject.name=$RELEASE_NAME --sort-by=.metadata.creationTimestamp | tail -10

echo "âœ… Health check complete"
```

## ğŸ“‹ Practice Exercises Summary

### Complete These Exercises:

#### Exercise 1: Basic Workflow
1. âœ… Install nginx chart with custom values
2. âœ… Upgrade with new configuration
3. âœ… Rollback after simulated failure
4. âœ… Clean up resources

#### Exercise 2: Multi-Environment
1. âœ… Deploy same app to dev/staging/prod
2. âœ… Use different configurations per environment
3. âœ… Compare resource usage
4. âœ… Practice environment promotion

#### Exercise 3: Configuration Management
1. âœ… Create base and environment-specific values
2. âœ… Use multiple values files in deployment
3. âœ… Override values with --set flags
4. âœ… Validate configurations with dry-run

#### Exercise 4: Troubleshooting
1. âœ… Create intentional deployment issues
2. âœ… Practice diagnosis using Helm and kubectl
3. âœ… Fix issues through upgrades or rollbacks
4. âœ… Monitor application health

#### Exercise 5: Advanced Scenarios
1. âœ… Implement blue-green deployment pattern
2. âœ… Practice canary deployments
3. âœ… Test disaster recovery procedures
4. âœ… Automate common operations

#### Exercise 6: Automation
1. âœ… Create deployment automation scripts
2. âœ… Build health check procedures
3. âœ… Implement validation pipelines
4. âœ… Practice CI/CD integration

## ğŸ“ Mastery Checklist

### You should now be able to:
- âœ… Install and configure Helm CLI
- âœ… Use essential Helm commands (list, get values, history)
- âœ… Understand chart structure and organization
- âœ… Upgrade releases using values files
- âœ… Set individual values with --set flags
- âœ… Perform rollbacks safely and effectively
- âœ… Use dry-runs to validate changes
- âœ… Deploy applications to multiple environments
- âœ… Troubleshoot common Helm issues
- âœ… Automate Helm operations with scripts
- âœ… Implement advanced deployment strategies
- âœ… Follow Helm best practices and security guidelines

## ğŸš€ Next Steps After Practice

### Continue Learning:
1. **Custom Chart Creation**: Learn to create your own Helm charts
2. **Chart Repositories**: Set up and manage chart repositories
3. **Helm Hooks**: Implement pre/post installation hooks
4. **Chart Testing**: Add automated testing to your charts
5. **Security**: Implement chart signing and verification
6. **Monitoring**: Integrate with monitoring solutions
7. **GitOps**: Implement GitOps workflows with ArgoCD or Flux

### Real-World Application:
- Apply these skills to your organization's applications
- Set up proper CI/CD pipelines with Helm
- Implement proper chart governance and security
- Share knowledge with your team
- Contribute to open-source Helm charts

## ğŸ‰ Congratulations!

You have completed the comprehensive Helm learning journey! You now have the practical skills to:
- Deploy and manage applications with Helm
- Handle complex multi-environment scenarios  
- Troubleshoot and recover from deployment issues
- Automate Helm operations effectively
- Follow industry best practices

Keep practicing these skills and continue exploring advanced Helm features as you encounter new use cases in your DevOps journey!



Bitnami/wordpress example

# Check what type of service WordPress is using
kubectl get svc my-wp-wordpress


# Method 1: Port Forward (Recommended for Windows/Minikube)
kubectl port-forward svc/my-wp-wordpress 8080:80

# Keep this terminal open and open a browser to:
# http://localhost:8080

minikube service my-wp-wordpress --url

## ğŸ—ï¸ Custom Chart Creation Example

### Create a new Helm chart from scratch
```powershell
# Create a new chart structure
helm create my-custom-app

# Explore the generated structure
ls my-custom-app/
# Chart.yaml, values.yaml, templates/, charts/, .helmignore

# Customize Chart.yaml
# Edit description, version, appVersion

# Customize values.yaml  
# Update replicaCount, image.tag, etc.

# Test with dry-run
helm install my-app ./my-custom-app --dry-run --debug

# Deploy the custom chart
helm install my-app ./my-custom-app

# Create custom values file
@'
replicaCount: 3
image:
  repository: nginx
  tag: "1.26.0"
service:
  type: NodePort
resources:
  limits:
    cpu: 300m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 256Mi
'@ | Out-File -FilePath my-custom-values.yaml -Encoding UTF8

# Upgrade with custom values
helm upgrade my-app ./my-custom-app -f my-custom-values.yaml

# Add custom ConfigMap template
# Create templates/configmap.yaml with templating

# Test the deployment
helm test my-app

# View all resources
kubectl get all -l app.kubernetes.io/instance=my-app
```



