# Edit ConfigMaps

## [ ] kubectl edit configmap, kubectl create configmap --from-file/--from-literal

### kubectl edit configmap
```bash
# Edit ConfigMap interactively
kubectl edit configmap <configmap-name>
kubectl edit cm <configmap-name>  # Short form

# Edit ConfigMap in specific namespace
kubectl edit configmap <configmap-name> -n <namespace-name>

# Edit with specific editor
EDITOR=nano kubectl edit configmap <configmap-name>

# Edit multiple ConfigMaps (opens each in sequence)
kubectl edit configmaps <configmap1> <configmap2>

# Edit with dry-run (preview changes without applying)
kubectl edit configmap <configmap-name> --dry-run=client
```

### How kubectl edit works
- Opens your default editor (usually vi/vim)
- Shows the complete YAML configuration
- Save and exit to apply changes
- Changes are applied immediately
- Invalid YAML will show error and reopen editor

### kubectl create configmap --from-literal
```bash
# Create ConfigMap with single literal value
kubectl create configmap app-config --from-literal=database_host=localhost

# Create with multiple literal values
kubectl create configmap app-config \
  --from-literal=database_host=localhost \
  --from-literal=database_port=5432 \
  --from-literal=debug_mode=true

# Create in specific namespace
kubectl create configmap app-config \
  --from-literal=env=production \
  -n production

# Create with labels
kubectl create configmap app-config \
  --from-literal=version=1.0 \
  -l app=myapp,environment=prod

# Dry run (preview without creating)
kubectl create configmap app-config \
  --from-literal=test=value \
  --dry-run=client -o yaml
```

### kubectl create configmap --from-file
```bash
# Create ConfigMap from single file
kubectl create configmap nginx-config --from-file=nginx.conf

# Create from file with custom key name
kubectl create configmap app-config --from-file=config=app.properties

# Create from multiple files
kubectl create configmap multi-config \
  --from-file=app.properties \
  --from-file=database.conf \
  --from-file=logging.xml

# Create from entire directory
kubectl create configmap dir-config --from-file=config/

# Create from directory with specific files
kubectl create configmap selective-config \
  --from-file=config/app.properties \
  --from-file=config/database.conf

# Combine file and literal values
kubectl create configmap mixed-config \
  --from-file=nginx.conf \
  --from-literal=server_name=myapp
```

## Additional Creation Methods

### From Environment Files
```bash
# Create from .env file
kubectl create configmap env-config --from-env-file=.env

# Example .env file content:
# DATABASE_HOST=localhost
# DATABASE_PORT=5432
# DEBUG=true

# Create from multiple env files
kubectl create configmap multi-env \
  --from-env-file=common.env \
  --from-env-file=production.env

# Combine env file with literals
kubectl create configmap combined-config \
  --from-env-file=.env \
  --from-literal=additional_key=value
```

### From YAML Manifests
```yaml
# configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: default
  labels:
    app: myapp
    environment: production
data:
  # Simple key-value pairs
  database_host: "localhost"
  database_port: "5432"
  log_level: "info"
  
  # Multi-line configuration files
  app.properties: |
    server.port=8080
    server.name=myapp
    database.url=jdbc:postgresql://localhost:5432/mydb
    logging.level=INFO
    cache.enabled=true
  
  # JSON configuration
  config.json: |
    {
      "server": {
        "host": "0.0.0.0",
        "port": 8080,
        "ssl": false
      },
      "database": {
        "host": "localhost",
        "port": 5432,
        "name": "myapp",
        "pool": {
          "min": 5,
          "max": 20
        }
      }
    }
  
  # Shell script configuration
  startup.sh: |
    #!/bin/bash
    echo "Starting application..."
    export DATABASE_URL=postgresql://localhost:5432/mydb
    exec /app/server
```

```bash
# Apply the YAML file
kubectl apply -f configmap.yaml

# Create or replace
kubectl replace -f configmap.yaml

# Apply with server-side validation
kubectl apply -f configmap.yaml --validate=true
```

## Updating ConfigMaps

### Patch Updates
```bash
# Add/update single key
kubectl patch configmap app-config -p '{"data":{"new_key":"new_value"}}'

# Update multiple keys
kubectl patch configmap app-config -p '{"data":{"key1":"value1","key2":"value2"}}'

# Strategic merge patch
kubectl patch configmap app-config --type merge -p '{"data":{"updated_key":"updated_value"}}'

# JSON patch (for complex operations)
kubectl patch configmap app-config --type='json' -p='[{"op": "replace", "path": "/data/database_host", "value": "new-host"}]'
```

### Replace Operations
```bash
# Replace entire ConfigMap from file
kubectl replace -f configmap.yaml

# Replace specific ConfigMap
kubectl replace configmap app-config --from-literal=database_host=newhost

# Replace with dry-run
kubectl replace -f configmap.yaml --dry-run=client -o yaml
```

## ConfigMap Creation Examples

### Application Configuration
```bash
# Web application config
kubectl create configmap web-config \
  --from-literal=server_port=8080 \
  --from-literal=server_host=0.0.0.0 \
  --from-literal=log_level=info \
  --from-literal=cache_enabled=true

# Database configuration
kubectl create configmap db-config \
  --from-literal=host=postgresql.default.svc.cluster.local \
  --from-literal=port=5432 \
  --from-literal=database=myapp \
  --from-literal=ssl_mode=require
```

### From Configuration Files
```bash
# Create nginx configuration
echo 'server { listen 80; server_name localhost; }' > nginx.conf
kubectl create configmap nginx-config --from-file=nginx.conf

# Create application properties
cat > app.properties << EOF
server.port=8080
database.url=jdbc:postgresql://localhost:5432/mydb
logging.level=INFO
EOF
kubectl create configmap app-props --from-file=app.properties

# Create from multiple configuration files
kubectl create configmap app-config \
  --from-file=nginx.conf \
  --from-file=app.properties \
  --from-literal=version=1.0
```

## Quick Reference Examples

```bash
# Edit operations
kubectl edit configmap app-config                    # Interactive edit
kubectl edit cm app-config -n production            # Edit in namespace

# Create from literals  
kubectl create cm app-config --from-literal=key=value           # Single value
kubectl create cm app-config --from-literal=k1=v1 --from-literal=k2=v2  # Multiple values

# Create from files
kubectl create cm nginx-config --from-file=nginx.conf           # From file
kubectl create cm app-config --from-file=config/                # From directory
kubectl create cm env-config --from-env-file=.env               # From env file

# Update operations
kubectl patch cm app-config -p '{"data":{"new":"value"}}'       # Patch update
kubectl replace -f configmap.yaml                               # Replace from file
```

## Best Practices

1. **Version control YAML files**: Keep ConfigMap manifests in Git
2. **Use descriptive names**: Make ConfigMap purpose clear from the name
3. **Add labels**: Use labels for organization and selection
4. **Validate before applying**: Use `--dry-run` to preview changes
5. **Backup before editing**: Save current state before major changes
6. **Use appropriate creation method**: Choose between literal, file, or YAML based on complexity