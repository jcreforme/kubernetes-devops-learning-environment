# 11. Network - Pod Communication

## How Pods Communicate Using Internal IPs

### Overview
Pods in Kubernetes can communicate directly with each other using their internal cluster IP addresses. This communication happens within the cluster network and doesn't require external routing or port forwarding.

### Pod Network Architecture

```
üè¢ KUBERNETES CLUSTER
    üì° Calico CNI Network: 10.244.0.0/16
    
    üñ•Ô∏è NODE: minikube (192.168.49.2)
        ‚îú‚îÄ‚îÄ Pod A: practice-pod (10.244.0.106)  - nginx web server
        ‚îú‚îÄ‚îÄ Pod B: client-pod   (10.244.0.108)  - busybox client  
        ‚îú‚îÄ‚îÄ Pod C: backend      (10.244.0.102)  - application
        ‚îî‚îÄ‚îÄ Pod D: frontend     (10.244.0.103)  - application
```

### Working Communication Examples

#### ‚úÖ **HTTP Communication**
```bash
# From client-pod (10.244.0.108) to practice-pod (10.244.0.106)
kubectl exec client-pod -- wget -qO- http://10.244.0.106

# Response: nginx welcome page
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
...
</html>
```

#### ‚úÖ **Network Connectivity Test**
```bash
# Ping test between pods
kubectl exec client-pod -- ping -c 3 10.244.0.106

# Results:
# 3 packets transmitted, 3 packets received, 0% packet loss
# round-trip min/avg/max = 0.183/1.846/5.127 ms
```

#### ‚úÖ **Creating Test Pods for Communication**
```bash
# Create nginx pod (server)
kubectl run practice-pod --image=nginx:latest

# Create client pod (client)
kubectl run client-pod --image=busybox -- sleep 300

# Check both pods and their IPs
kubectl get pods -o wide
```

### Key Characteristics of Pod-to-Pod Communication

#### **Direct IP Access**
- Pods communicate using cluster IPs (e.g., `10.244.0.x`)
- No NAT (Network Address Translation) between pods
- Direct routing within the cluster network

#### **Network Performance**
- **Low Latency**: ~1ms response time between pods
- **High Bandwidth**: No throttling within cluster
- **No Packet Loss**: Reliable communication

#### **Security Model**
- **No Firewalls by Default**: All ports accessible
- **Same Network Segment**: All pods on `10.244.0.0/16`
- **Cluster-Only**: Not accessible from outside cluster

### Practical Use Cases

#### **Microservices Architecture**
```bash
# Frontend calling backend API
kubectl exec frontend-pod -- curl http://10.244.0.102/api/users

# Backend connecting to database
kubectl exec backend-pod -- telnet 10.244.0.88 5432

# Service mesh communication
kubectl exec app-pod -- curl http://10.244.0.95/health
```

#### **Database Connections**
```bash
# Application connecting to database pod
kubectl exec app-pod -- mysql -h 10.244.0.88 -u user -p database_name

# Redis cache access
kubectl exec web-app -- redis-cli -h 10.244.0.91 ping
```

#### **File Sharing and APIs**
```bash
# File transfer between pods
kubectl exec pod1 -- scp file.txt 10.244.0.106:/tmp/

# REST API calls
kubectl exec client -- curl -X POST http://10.244.0.105/api/data
```

### Network Limitations

#### **‚ùå External Access**
- Pod IPs are **NOT** accessible from outside the cluster
- Cannot access `http://10.244.0.106` from your browser
- Need port-forwarding or Services for external access

#### **‚ùå DNS Resolution**
- Direct IP addresses don't have automatic DNS names
- Need Services or custom DNS for name resolution
- `nslookup` may fail for pod IPs

### Accessing Pods from Outside the Cluster

#### **Method 1: Port Forwarding**
```bash
# Forward local port to pod
kubectl port-forward practice-pod 8080:80

# Then access: http://localhost:8080
```

#### **Method 2: Expose as Service**
```bash
# Create service to expose pod
kubectl expose pod practice-pod --port=80 --target-port=80 --name=practice-service

# Access via service IP
kubectl get service practice-service
```

#### **Method 3: Minikube Service**
```bash
# For minikube environments
minikube service practice-service --url
```

### Network Troubleshooting Commands

#### **Check Pod Network Configuration**
```bash
# Get pod IPs and nodes
kubectl get pods -o wide

# Describe pod networking
kubectl describe pod practice-pod

# Check cluster network info
kubectl get nodes -o wide
```

#### **Test Network Connectivity**
```bash
# Ping test
kubectl exec client-pod -- ping -c 3 <target-pod-ip>

# Port connectivity test
kubectl exec client-pod -- telnet <target-pod-ip> <port>

# HTTP test
kubectl exec client-pod -- wget -qO- http://<target-pod-ip>

# DNS test
kubectl exec client-pod -- nslookup <target-pod-ip>
```

#### **Network Policy Testing**
```bash
# Check if network policies are blocking communication
kubectl get networkpolicies

# Test different protocols
kubectl exec client-pod -- nc -zv <target-pod-ip> <port>
```

### Best Practices

#### **1. Use Services Instead of Direct IPs**
- Pod IPs change when pods restart
- Services provide stable endpoints
- Better for production environments

#### **2. Implement Network Security**
```bash
# Use Network Policies to control traffic
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-specific-traffic
spec:
  podSelector: {}
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: allowed-client
```

#### **3. Monitor Network Performance**
```bash
# Check network metrics
kubectl top pods
kubectl describe nodes

# Test network bandwidth
kubectl exec pod1 -- iperf3 -c <target-pod-ip>
```

### Summary

Pod-to-pod communication using internal IPs provides:

- ‚úÖ **Fast, direct communication** within the cluster
- ‚úÖ **No configuration required** for basic connectivity  
- ‚úÖ **Low latency** (~1ms) and high performance
- ‚úÖ **All ports accessible** by default
- ‚ùå **Not accessible from outside** the cluster
- ‚ùå **IPs change** when pods restart

For production workloads, use Services for stable networking, but understanding direct IP communication is crucial for troubleshooting and advanced networking scenarios.