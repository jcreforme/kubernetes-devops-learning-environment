# Deployments

## What are Deployments?

**Deployments** are a Kubernetes resource that manages the lifecycle of your applications. Think of them as a "blueprint" that tells Kubernetes:
- **What to run**: Which container image and configuration to use
- **How many to run**: Number of replicas (pod instances) 
- **How to update**: Rolling updates, rollbacks, and scaling strategies

### Key Benefits:
- **Declarative Management**: You describe what you want, Kubernetes makes it happen
- **Self-Healing**: Automatically replaces failed pods
- **Rolling Updates**: Updates applications without downtime
- **Rollback Capability**: Easily revert to previous versions
- **Scaling**: Increase/decrease replicas based on demand

### Real-World Example:
```
You want to run 3 copies of your web application:
- Deployment ensures 3 pods are always running
- If 1 pod crashes, Deployment creates a new one
- When you update your app, Deployment gradually replaces old pods with new ones
- If the update fails, you can instantly rollback
```

### Deployment vs Pods:
| Pods | Deployments |
|------|-------------|
| Individual container instances | Manages multiple pods |
| Manual lifecycle management | Automated management |
| No self-healing | Self-healing and replacement |
| No update strategy | Rolling updates/rollbacks |

## [ ] kubectl get deployments, kubectl scale deployment, kubectl rollout status/history/undo

### kubectl get deployments
```bash
# Get all deployments in current namespace
kubectl get deployments

# Get deployments with detailed information
kubectl get deployments -o wide

# Get deployments from all namespaces
kubectl get deployments --all-namespaces
kubectl get deployments -A

# Get specific deployment
kubectl get deployment <deployment-name>

# Watch deployments for changes
kubectl get deployments -w

# Get deployments with labels
kubectl get deployments -l app=myapp

# Custom output formats
kubectl get deployments -o yaml
kubectl get deployments -o json

# Show deployment with replica information
kubectl get deployments --show-labels
```

### kubectl scale deployment
```bash
# Scale deployment to specific number of replicas
kubectl scale deployment <deployment-name> --replicas=5

# Scale deployment in specific namespace
kubectl scale deployment <deployment-name> --replicas=3 -n <namespace>

# Scale multiple deployments at once
kubectl scale deployment web-app api-service --replicas=2

# Scale with conditions (only if current replicas match)
kubectl scale deployment <deployment-name> --current-replicas=2 --replicas=3

# Check current scale
kubectl get deployment <deployment-name>

# Scale to zero (stop all pods)
kubectl scale deployment <deployment-name> --replicas=0

# Auto-scale setup (HorizontalPodAutoscaler)
kubectl autoscale deployment <deployment-name> --min=2 --max=10 --cpu=70%

# ‚ö†Ô∏è IMPORTANT: HPA requires CPU resource requests to be defined in deployment
# If you see "missing request for cpu" errors, update your deployment:
# kubectl patch deployment <deployment-name> -p '{"spec":{"template":{"spec":{"containers":[{"name":"<container-name>","resources":{"requests":{"cpu":"100m"}}}]}}}}'

# Check autoscaler status
kubectl get hpa
kubectl describe hpa <deployment-name>

# Delete autoscaler
kubectl delete hpa <deployment-name>
```

## Stopping Deployments

```bash
# Method 1: Scale to zero (temporary stop - keeps deployment)
kubectl scale deployment <deployment-name> --replicas=0

# Method 2: Delete deployment (permanent removal)
kubectl delete deployment <deployment-name>

# Method 3: Pause rollout (stop updates, keep pods running)
kubectl rollout pause deployment/<deployment-name>

# Resume paused rollout
kubectl rollout resume deployment/<deployment-name>

# Restart all pods (rolling restart)
kubectl rollout restart deployment/<deployment-name>
```

### kubectl rollout status
```bash
# Check rollout status of a deployment
kubectl rollout status deployment/<deployment-name>

# Check status with timeout
kubectl rollout status deployment/<deployment-name> --timeout=300s

# Watch rollout progress in real-time
kubectl rollout status deployment/<deployment-name> -w

# Check if rollout is complete
kubectl rollout status deployment/<deployment-name> --watch=false

# Check rollout status for different resource types
kubectl rollout status daemonset/<daemonset-name>
kubectl rollout status statefulset/<statefulset-name>
```

**What "Successfully Rolled Out" Means:**
- ‚úÖ All replicas are updated with latest configuration
- ‚úÖ All replicas are ready and passing health checks  
- ‚úÖ No pod failures during the update process
- ‚úÖ Desired state matches actual state (correct replicas, image version, etc.)

### kubectl rollout history
```bash
# View rollout history
kubectl rollout history deployment/<deployment-name>

# View specific revision details
kubectl rollout history deployment/<deployment-name> --revision=2

# View history with more details
kubectl rollout history deployment/<deployment-name> --revision=1 -o yaml

# Compare two revisions
kubectl rollout history deployment/<deployment-name> --revision=2 -o yaml
kubectl rollout history deployment/<deployment-name> --revision=3 -o yaml

# View change cause (if recorded)
kubectl annotate deployment/<deployment-name> deployment.kubernetes.io/change-cause="Updated to nginx 1.21"
kubectl rollout history deployment/<deployment-name>
```

**Understanding Revisions:**
- **Revision numbers** = Different versions of your deployment configuration
- **New revisions created by**: image updates, config changes, resource modifications
- **Scaling replicas does NOT create new revisions**
- **CHANGE-CAUSE shows `<none>`** when no annotation was recorded during the change

**To record change causes:**
```bash
# Add change-cause before making changes
kubectl annotate deployment/<deployment-name> deployment.kubernetes.io/change-cause="Updated nginx to version 1.22"
kubectl set image deployment/<deployment-name> nginx=nginx:1.22

# Or use --record flag (deprecated but still works)
kubectl set image deployment/<deployment-name> nginx=nginx:1.22 --record
```

### kubectl rollout undo
```bash
# Rollback to previous version
kubectl rollout undo deployment/<deployment-name>

# Rollback to specific revision
kubectl rollout undo deployment/<deployment-name> --to-revision=2

# Rollback with dry-run (preview changes)
kubectl rollout undo deployment/<deployment-name> --dry-run=client

# Rollback and monitor
kubectl rollout undo deployment/<deployment-name>
kubectl rollout status deployment/<deployment-name>

# Rollback other resource types
kubectl rollout undo daemonset/<daemonset-name>
kubectl rollout undo statefulset/<statefulset-name>
```

**Understanding Rollback Behavior:**
- ‚úÖ **Rollback DOES occur**: Configuration reverts to previous revision
- üìù **New revision created**: Rollback creates a new revision number (not reuses old one)
- üóëÔ∏è **Old revision may disappear**: Kubernetes maintains limited history (default 10 revisions)
- **Example**: Rollback from rev 3‚Üí2 creates new rev 4 (identical to old rev 2)

## Common Deployment Operations

```bash
# Create deployment
kubectl create deployment nginx-app --image=nginx:1.21

# Update deployment image
kubectl set image deployment/nginx-app nginx=nginx:1.22

# Restart deployment (rolling restart)
kubectl rollout restart deployment/nginx-app

# Pause rollout
kubectl rollout pause deployment/nginx-app

# Resume rollout
kubectl rollout resume deployment/nginx-app

# Check deployment details
kubectl describe deployment nginx-app
```

## Checking Container Versions

```bash
# Method 1: Check deployment configuration
kubectl describe deployment <deployment-name>  # Look for "Image:" field
kubectl get deployment <deployment-name> -o jsonpath='{.spec.template.spec.containers[0].image}'

# Method 2: Check running pods  
kubectl describe pods -l app=<app-label>       # Look for "Image:" field
kubectl get pods -l app=<app-label> -o jsonpath='{.items[*].spec.containers[*].image}'

# Method 3: Check replica sets
kubectl get replicasets -l app=<app-label> -o wide  # IMAGE column shows container image

# Method 4: Execute into container (most accurate)
kubectl exec -it deployment/<deployment-name> -- nginx -v     # For nginx version
kubectl exec deployment/<deployment-name> -- <command> -v     # For other applications
```

## Deployment Status Fields

| Field | Description |
|-------|-------------|
| READY | Number of ready replicas vs desired |
| UP-TO-DATE | Number of replicas with latest configuration |
| AVAILABLE | Number of replicas available to users |
| AGE | Time since deployment creation |

## Viewing Replicas

```bash
# Quick replica overview
kubectl get deployments                    # Shows READY column (2/2 = 2 ready out of 2 desired)
kubectl get deployment <deployment-name>   # Specific deployment replica status

# Detailed replica information
kubectl describe deployment <deployment-name>  # Shows replica details, conditions, events

# View underlying replica sets
kubectl get replicasets                    # Shows ReplicaSets managing the pods
kubectl get rs -l app=<app-label>         # Filter by app label

# View individual pod replicas
kubectl get pods                           # Shows individual pod instances
kubectl get pods -l app=<app-label>       # Filter pods by deployment label

# Wide output with more details
kubectl get deployments -o wide           # Additional columns with replica info
kubectl get pods -o wide                  # More pod details including node info

# Real-time monitoring
kubectl get deployments -w                # Watch deployment replica changes
kubectl get pods -w                       # Watch pod replica changes
```

## Quick Reference Workflow

```bash
# Standard deployment workflow
kubectl get deployments                           # List deployments
kubectl scale deployment myapp --replicas=3      # Scale up/down
kubectl rollout status deployment/myapp          # Check rollout
kubectl rollout history deployment/myapp         # View history
kubectl rollout undo deployment/myapp            # Rollback if needed
```