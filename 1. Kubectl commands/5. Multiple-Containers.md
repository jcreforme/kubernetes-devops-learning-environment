# Multiple Containers

## [ ] kubectl logs -c

### kubectl logs -c
```bash
# Get logs from specific container in multi-container pod
kubectl logs <pod-name> -c <container-name>

# Get logs from specific container with follow
kubectl logs <pod-name> -c <container-name> -f

# Get previous logs from specific container
kubectl logs <pod-name> -c <container-name> --previous

# Get logs from specific container with timestamps
kubectl logs <pod-name> -c <container-name> --timestamps

# Get logs from specific container with tail
kubectl logs <pod-name> -c <container-name> --tail=50

# Get logs from specific container in specific namespace
kubectl logs <pod-name> -c <container-name> -n <namespace-name>
```

## Finding and Creating Multi-Container Pods

### Finding Existing Multi-Container Pods
```bash
# List all pods and check container count
kubectl get pods -o wide

# Find which pods have multiple containers
kubectl get pods -o jsonpath='{range .items[*]}{.metadata.name}{" containers: "}{.spec.containers[*].name}{"\n"}{end}'

# Check containers in a specific pod
kubectl describe pod <pod-name>
kubectl get pod <pod-name> -o jsonpath='{.spec.containers[*].name}'
```

### Creating a Multi-Container Pod for Practice
```bash
# Create a simple multi-container pod YAML file
cat <<EOF > multi-container-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: multi-container-pod
spec:
  containers:
  - name: web-server
    image: nginx:alpine
    ports:
    - containerPort: 80
  - name: log-generator  
    image: busybox
    command: ["/bin/sh"]
    args: ["-c", "while true; do echo 'Log from sidecar container'; sleep 5; done"]
EOF

# Apply the pod
kubectl apply -f multi-container-pod.yaml

# Wait for pod to be ready
kubectl get pod multi-container-pod

# Now practice the commands!
kubectl logs multi-container-pod -c web-server
kubectl logs multi-container-pod -c log-generator
```

## Working with Multi-Container Pods

### List Containers in Pod
```bash
# Find container names in a pod
kubectl describe pod <pod-name>

# Get container names using jsonpath
kubectl get pod <pod-name> -o jsonpath='{.spec.containers[*].name}'

# Get detailed container information
kubectl get pod <pod-name> -o yaml | grep -A 10 containers:

# Show container statuses
kubectl get pod <pod-name> -o jsonpath='{.status.containerStatuses[*].name}'
```

### All Container Operations
```bash
# Get logs from all containers in pod
kubectl logs <pod-name> --all-containers=true

# Follow logs from all containers
kubectl logs <pod-name> --all-containers=true -f

# Get logs from all containers with container name prefix
kubectl logs <pod-name> --all-containers=true --prefix=true

# Get previous logs from all containers
kubectl logs <pod-name> --all-containers=true --previous

# Get logs from all containers with timestamps
kubectl logs <pod-name> --all-containers=true --timestamps
```

## Common Multi-Container Scenarios

### Sidecar Pattern
```bash
# Main application container
kubectl logs web-pod -c app

# Logging sidecar container
kubectl logs web-pod -c log-collector

# Monitoring sidecar container
kubectl logs web-pod -c metrics-exporter
```

### Init Container Logs
```bash
# Get logs from init containers
kubectl logs <pod-name> -c <init-container-name>

# Init containers run before main containers
# Check init container logs if pod is stuck in Init state
kubectl describe pod <pod-name> | grep -A 10 "Init Containers"
```

### Application with Proxy
```bash
# Application container logs
kubectl logs my-app -c application

# Proxy container logs (like Istio sidecar)
kubectl logs my-app -c istio-proxy

# Follow both containers
kubectl logs my-app --all-containers=true -f --prefix=true
```

## Troubleshooting Multi-Container Pods

### Debug Container Issues
```bash
# Check which containers are running
kubectl get pod <pod-name> -o jsonpath='{.status.containerStatuses[*].name}'

# Check container states
kubectl describe pod <pod-name>

# Get logs from failed container
kubectl logs <pod-name> -c <failed-container> --previous

# Check specific container restart count
kubectl get pod <pod-name> -o jsonpath='{.status.containerStatuses[?(@.name=="container-name")].restartCount}'
```

### Container Status Checking
```bash
# Check if specific container is ready
kubectl get pod <pod-name> -o jsonpath='{.status.containerStatuses[?(@.name=="container-name")].ready}'

# Get container states
kubectl get pod <pod-name> -o jsonpath='{.status.containerStatuses[*].state}'

# Check container images
kubectl get pod <pod-name> -o jsonpath='{.spec.containers[*].image}'
```

## Execute Commands in Specific Containers

```bash
# Execute command in specific container
kubectl exec <pod-name> -c <container-name> -- <command>

# Interactive shell in specific container
kubectl exec -it <pod-name> -c <container-name> -- /bin/bash

# Run command in specific container
kubectl exec <pod-name> -c <container-name> -- ps aux
kubectl exec <pod-name> -c <container-name> -- ls -la /app
```

## Quick Reference Examples

```bash
# Multi-container pod operations
kubectl logs my-pod -c web-server              # Specific container logs
kubectl logs my-pod -c sidecar                 # Sidecar logs
kubectl logs my-pod --all-containers=true      # All container logs
kubectl logs my-pod --all-containers=true -f   # Follow all containers

# Debugging multi-container pods
kubectl describe pod my-pod                     # See all container statuses
kubectl logs my-pod -c app --previous          # Previous logs from specific container
kubectl exec -it my-pod -c web -- /bin/bash    # Shell into specific container
```

## Common Container Types

| Container Type | Purpose | Example Names |
|---------------|---------|---------------|
| Main Application | Primary application logic | app, web, api, service |
| Sidecar | Supporting functionality | log-collector, metrics, proxy |
| Init Container | Initialization tasks | init, setup, migrate |
| Proxy/Service Mesh | Network proxy | istio-proxy, envoy, linkerd |
| Monitoring | Metrics collection | prometheus-exporter, datadog-agent |