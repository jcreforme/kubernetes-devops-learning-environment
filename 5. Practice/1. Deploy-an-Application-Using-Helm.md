# 1. Deploy an Application Using Helm

## üéØ Learning Objectives
- [ ] Set up a Helm chart for application deployment
- [ ] Deploy application to development and production environments
- [ ] Configure environment-specific values
- [ ] Validate successful deployment
- [ ] Understand Helm release management

## üìã Prerequisites
- Kubernetes cluster access
- Helm 3.x installed
- kubectl configured
- Basic understanding of Kubernetes resources

## üöÄ Step 1: Create Helm Chart Structure

### Initialize New Helm Chart
```bash
# Create a new Helm chart
helm create my-app

# Examine the generated structure
cd my-app
tree .
```

### Chart Structure Overview
```
my-app/
‚îú‚îÄ‚îÄ Chart.yaml          # Chart metadata
‚îú‚îÄ‚îÄ values.yaml         # Default configuration values
‚îú‚îÄ‚îÄ charts/             # Chart dependencies
‚îú‚îÄ‚îÄ templates/          # Kubernetes manifest templates
‚îÇ   ‚îú‚îÄ‚îÄ deployment.yaml
‚îÇ   ‚îú‚îÄ‚îÄ service.yaml
‚îÇ   ‚îú‚îÄ‚îÄ ingress.yaml
‚îÇ   ‚îú‚îÄ‚îÄ configmap.yaml
‚îÇ   ‚îî‚îÄ‚îÄ _helpers.tpl    # Template helpers
‚îî‚îÄ‚îÄ .helmignore        # Files to ignore during packaging
```

## üìù Step 2: Configure Chart Metadata

### Update Chart.yaml
```yaml
# Chart.yaml
apiVersion: v2
name: my-app
description: A sample web application Helm chart
type: application
version: 0.1.0
appVersion: "1.0"

keywords:
  - web
  - nodejs
  - sample

maintainers:
  - name: Platform Team
    email: platform@company.com

sources:
  - https://github.com/company/my-app
```

### Configure Default Values
```yaml
# values.yaml
# Default values for my-app
replicaCount: 1

image:
  repository: nginx
  pullPolicy: IfNotPresent
  tag: "1.21"

nameOverride: ""
fullnameOverride: ""

service:
  type: ClusterIP
  port: 80
  targetPort: 8080

ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts:
    - host: my-app.local
      paths:
        - path: /
          pathType: Prefix
  tls: []

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80

nodeSelector: {}
tolerations: []
affinity: {}

# Application-specific configuration
app:
  name: my-sample-app
  environment: development
  logLevel: info
  database:
    host: postgres.default.svc.cluster.local
    port: 5432
    name: myapp
```

## üèóÔ∏è Step 3: Create Application Templates

### Deployment Template
```yaml
# templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "my-app.fullname" . }}
  labels:
    {{- include "my-app.labels" . | nindent 4 }}
spec:
  {{- if not .Values.autoscaling.enabled }}
  replicas: {{ .Values.replicaCount }}
  {{- end }}
  selector:
    matchLabels:
      {{- include "my-app.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      annotations:
        checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
      labels:
        {{- include "my-app.selectorLabels" . | nindent 8 }}
    spec:
      containers:
        - name: {{ .Chart.Name }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - name: http
              containerPort: {{ .Values.service.targetPort }}
              protocol: TCP
          env:
            - name: APP_NAME
              value: {{ .Values.app.name }}
            - name: ENVIRONMENT
              value: {{ .Values.app.environment }}
            - name: LOG_LEVEL
              value: {{ .Values.app.logLevel }}
            - name: DATABASE_HOST
              value: {{ .Values.app.database.host }}
            - name: DATABASE_PORT
              value: {{ .Values.app.database.port | quote }}
          envFrom:
            - configMapRef:
                name: {{ include "my-app.fullname" . }}-config
          livenessProbe:
            httpGet:
              path: /health
              port: http
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /ready
              port: http
            initialDelaySeconds: 5
            periodSeconds: 5
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
      {{- with .Values.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}
```

### ConfigMap Template
```yaml
# templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "my-app.fullname" . }}-config
  labels:
    {{- include "my-app.labels" . | nindent 4 }}
data:
  app.properties: |
    app.name={{ .Values.app.name }}
    app.environment={{ .Values.app.environment }}
    log.level={{ .Values.app.logLevel }}
    
    # Database configuration
    database.host={{ .Values.app.database.host }}
    database.port={{ .Values.app.database.port }}
    database.name={{ .Values.app.database.name }}
    
    # Feature flags
    features.monitoring.enabled=true
    features.metrics.enabled={{ .Values.app.environment | eq "production" }}
    
  nginx.conf: |
    server {
        listen {{ .Values.service.targetPort }};
        server_name _;
        
        location / {
            root   /usr/share/nginx/html;
            index  index.html index.htm;
            try_files $uri $uri/ /index.html;
        }
        
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
        
        location /ready {
            access_log off;
            return 200 "ready\n";
            add_header Content-Type text/plain;
        }
    }
```

## üåç Step 4: Environment-Specific Configurations

### Development Environment Values
```yaml
# values-dev.yaml
replicaCount: 1

image:
  repository: my-app
  tag: "dev-latest"

app:
  environment: development
  logLevel: debug
  database:
    host: postgres-dev.default.svc.cluster.local
    name: myapp_dev

resources:
  requests:
    cpu: 100m
    memory: 128Mi
  limits:
    cpu: 200m
    memory: 256Mi

ingress:
  enabled: true
  className: nginx
  hosts:
    - host: my-app-dev.company.local
      paths:
        - path: /
          pathType: Prefix

# Development-specific settings
nodeSelector:
  node-type: development
```

### Production Environment Values
```yaml
# values-prod.yaml
replicaCount: 3

image:
  repository: my-app
  tag: "1.2.3"

app:
  environment: production
  logLevel: warn
  database:
    host: postgres-prod.database.svc.cluster.local
    name: myapp_prod

resources:
  requests:
    cpu: 500m
    memory: 512Mi
  limits:
    cpu: 1000m
    memory: 1Gi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70

ingress:
  enabled: true
  className: nginx
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rate-limit: "100"
  hosts:
    - host: my-app.company.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: my-app-tls
      hosts:
        - my-app.company.com

# Production-specific settings
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
            - my-app
        topologyKey: kubernetes.io/hostname
```

## üì¶ Step 5: Deploy Application

### Validate Helm Chart
```bash
# Lint the chart
helm lint my-app

# Validate against Kubernetes API
helm template my-app ./my-app --values ./my-app/values-dev.yaml --validate

# Check for any issues
helm template my-app ./my-app --values ./my-app/values-dev.yaml --debug
```

### Deploy to Development
```bash
# Create development namespace
kubectl create namespace development

# Install to development
helm install my-app-dev ./my-app \
  --namespace development \
  --values ./my-app/values-dev.yaml \
  --wait \
  --timeout 300s

# Check installation status
helm status my-app-dev --namespace development
```

### Deploy to Production
```bash
# Create production namespace
kubectl create namespace production

# Install to production
helm install my-app-prod ./my-app \
  --namespace production \
  --values ./my-app/values-prod.yaml \
  --wait \
  --timeout 300s

# Check installation status
helm status my-app-prod --namespace production
```

## ‚úÖ Step 6: Verification and Testing

### Verify Deployments
```bash
# Check development deployment
kubectl get all -n development -l app.kubernetes.io/name=my-app

# Check production deployment
kubectl get all -n production -l app.kubernetes.io/name=my-app

# Check pod logs
kubectl logs -n development -l app.kubernetes.io/name=my-app --tail=50
kubectl logs -n production -l app.kubernetes.io/name=my-app --tail=50
```

### Test Application Connectivity
```bash
# Port forward to test locally
kubectl port-forward -n development svc/my-app-dev 8080:80

# Test health endpoints
curl http://localhost:8080/health
curl http://localhost:8080/ready

# Test application
curl http://localhost:8080/
```

### Verify Environment Configuration
```bash
# Check ConfigMaps
kubectl get configmap -n development my-app-dev-config -o yaml
kubectl get configmap -n production my-app-prod-config -o yaml

# Verify environment variables in pods
kubectl exec -n development -it deployment/my-app-dev -- env | grep -E "(APP_|DATABASE_|ENVIRONMENT)"
kubectl exec -n production -it deployment/my-app-prod -- env | grep -E "(APP_|DATABASE_|ENVIRONMENT)"
```

## üìä Step 7: Monitor Deployment

### Check Helm Releases
```bash
# List all releases
helm list --all-namespaces

# Get release history
helm history my-app-dev --namespace development
helm history my-app-prod --namespace production

# Check release notes
helm get notes my-app-dev --namespace development
```

### Monitor Resource Usage
```bash
# Check resource utilization
kubectl top pods -n development -l app.kubernetes.io/name=my-app
kubectl top pods -n production -l app.kubernetes.io/name=my-app

# Check HPA status (production only)
kubectl get hpa -n production
```

## üéØ Success Criteria

### ‚úÖ Deployment Checklist
- [ ] Helm chart successfully created and structured
- [ ] Environment-specific values configured
- [ ] Applications deployed to both development and production
- [ ] All pods running and healthy
- [ ] Health checks responding correctly
- [ ] ConfigMaps applied with correct values
- [ ] Services accessible
- [ ] Ingress configured (if enabled)
- [ ] HPA working (production)

### ‚úÖ Validation Commands
```bash
# All these should succeed:
helm status my-app-dev -n development
helm status my-app-prod -n production
kubectl get pods -n development -l app.kubernetes.io/name=my-app
kubectl get pods -n production -l app.kubernetes.io/name=my-app
curl -f http://localhost:8080/health  # After port-forward
```

## üßπ Cleanup (Optional)

### Remove Deployments
```bash
# Uninstall releases
helm uninstall my-app-dev --namespace development
helm uninstall my-app-prod --namespace production

# Delete namespaces
kubectl delete namespace development
kubectl delete namespace production
```

## üéì Key Takeaways

### What You've Learned
1. **Helm Chart Structure**: Understanding templates, values, and helpers
2. **Environment Configuration**: Managing different environments with values files
3. **Template Functions**: Using Helm template functions and variables
4. **Release Management**: Installing, upgrading, and managing Helm releases
5. **Validation**: Testing and validating Helm charts before deployment

This exercise demonstrates a complete application deployment workflow using Helm, from chart creation through production deployment with proper environment separation and configuration management.

## ‚û°Ô∏è Next Steps
Proceed to [2. Update ConfigMap via kubectl](2.%20Update-ConfigMap-via-kubectl.md) to learn how to modify application configuration using kubectl commands.