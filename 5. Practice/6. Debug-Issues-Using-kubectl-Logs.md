# 6. Debug Any Issues Using kubectl Logs

## üéØ Learning Objectives
- [ ] Master kubectl logs command variations and options
- [ ] Implement structured debugging workflows
- [ ] Combine kubectl logs with other debugging tools
- [ ] Create automated debugging and troubleshooting scripts
- [ ] Integrate local debugging with CloudWatch monitoring

## üìã Prerequisites
- Kubernetes cluster access with kubectl configured
- Applications deployed from previous exercises
- Basic understanding of Kubernetes pod lifecycle
- CloudWatch logging setup (optional but recommended)

## üîç Step 1: kubectl Logs Fundamentals

### Basic Log Commands
```bash
# Get logs from a specific pod
kubectl logs my-pod-name

# Get logs from deployment (all pods)
kubectl logs deployment/my-deployment

# Get logs with label selector
kubectl logs -l app=my-app

# Get logs from specific container in multi-container pod
kubectl logs my-pod-name -c container-name

# Get logs from all containers in a pod
kubectl logs my-pod-name --all-containers=true

# Stream logs in real-time
kubectl logs -f deployment/my-deployment

# Get previous container logs (after restart)
kubectl logs my-pod-name --previous
```

### Advanced Log Options
```bash
# Get logs with timestamps
kubectl logs deployment/my-deployment --timestamps=true

# Get specific number of recent log lines
kubectl logs deployment/my-deployment --tail=50

# Get logs since specific time
kubectl logs deployment/my-deployment --since=1h
kubectl logs deployment/my-deployment --since-time=2024-02-03T10:00:00Z

# Get logs with resource limits (to prevent overwhelming output)
kubectl logs deployment/my-deployment --limit-bytes=1048576  # 1MB limit

# Get logs from multiple pods in parallel
kubectl logs -l app=my-app --prefix=true --timestamps=true
```

## üõ†Ô∏è Step 2: Create Comprehensive Debugging Scripts

### Basic Debugging Script
```bash
# Create debugging utility script
cat << 'EOF' > debug-kubectl-logs.sh
#!/bin/bash

set -e

# Configuration
NAMESPACE=${1:-default}
APP_LABEL=${2:-"app.kubernetes.io/name=my-app"}
OUTPUT_DIR=${3:-"debug-logs-$(date +%Y%m%d-%H%M%S)"}

echo "üîç Starting kubectl logs debugging session"
echo "Namespace: $NAMESPACE"
echo "Label Selector: $APP_LABEL"
echo "Output Directory: $OUTPUT_DIR"

# Create output directory
mkdir -p "$OUTPUT_DIR"

# Function to log with timestamp
log_with_timestamp() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$OUTPUT_DIR/debug-session.log"
}

# Get basic cluster information
log_with_timestamp "=== CLUSTER INFORMATION ==="
kubectl cluster-info > "$OUTPUT_DIR/cluster-info.txt" 2>&1
kubectl version --short > "$OUTPUT_DIR/version-info.txt" 2>&1
kubectl get nodes -o wide > "$OUTPUT_DIR/nodes-info.txt" 2>&1

# Get pod information
log_with_timestamp "=== POD INFORMATION ==="
kubectl get pods -n "$NAMESPACE" -l "$APP_LABEL" -o wide > "$OUTPUT_DIR/pods-status.txt" 2>&1
kubectl describe pods -n "$NAMESPACE" -l "$APP_LABEL" > "$OUTPUT_DIR/pods-describe.txt" 2>&1

# Get service information
log_with_timestamp "=== SERVICE INFORMATION ==="
kubectl get services -n "$NAMESPACE" -l "$APP_LABEL" -o wide > "$OUTPUT_DIR/services-status.txt" 2>&1
kubectl describe services -n "$NAMESPACE" -l "$APP_LABEL" > "$OUTPUT_DIR/services-describe.txt" 2>&1

# Get events
log_with_timestamp "=== EVENTS ==="
kubectl get events -n "$NAMESPACE" --sort-by=.metadata.creationTimestamp > "$OUTPUT_DIR/events.txt" 2>&1

# Get logs from all pods
log_with_timestamp "=== COLLECTING LOGS ==="
pod_names=$(kubectl get pods -n "$NAMESPACE" -l "$APP_LABEL" -o jsonpath='{.items[*].metadata.name}')

if [ -z "$pod_names" ]; then
    log_with_timestamp "‚ùå No pods found with label: $APP_LABEL"
    exit 1
fi

for pod in $pod_names; do
    log_with_timestamp "üìã Collecting logs for pod: $pod"
    
    # Current logs
    kubectl logs -n "$NAMESPACE" "$pod" --all-containers=true --timestamps=true > "$OUTPUT_DIR/logs-$pod-current.txt" 2>&1
    
    # Previous logs (if container restarted)
    kubectl logs -n "$NAMESPACE" "$pod" --previous --all-containers=true --timestamps=true > "$OUTPUT_DIR/logs-$pod-previous.txt" 2>&1 || echo "No previous logs for $pod"
    
    # Get container information
    kubectl get pod -n "$NAMESPACE" "$pod" -o jsonpath='{.spec.containers[*].name}' > "$OUTPUT_DIR/containers-$pod.txt" 2>&1
    
    # Individual container logs
    containers=$(kubectl get pod -n "$NAMESPACE" "$pod" -o jsonpath='{.spec.containers[*].name}')
    for container in $containers; do
        log_with_timestamp "üì¶ Container logs: $pod/$container"
        kubectl logs -n "$NAMESPACE" "$pod" -c "$container" --timestamps=true > "$OUTPUT_DIR/logs-$pod-$container.txt" 2>&1
        kubectl logs -n "$NAMESPACE" "$pod" -c "$container" --previous --timestamps=true > "$OUTPUT_DIR/logs-$pod-$container-previous.txt" 2>&1 || true
    done
done

# Resource utilization
log_with_timestamp "=== RESOURCE UTILIZATION ==="
kubectl top pods -n "$NAMESPACE" -l "$APP_LABEL" > "$OUTPUT_DIR/resource-usage.txt" 2>&1 || echo "Metrics server not available"

# ConfigMaps and Secrets
log_with_timestamp "=== CONFIGURATION ==="
kubectl get configmaps -n "$NAMESPACE" > "$OUTPUT_DIR/configmaps.txt" 2>&1
kubectl get secrets -n "$NAMESPACE" > "$OUTPUT_DIR/secrets.txt" 2>&1

# Network information
log_with_timestamp "=== NETWORK INFORMATION ==="
kubectl get ingress -n "$NAMESPACE" > "$OUTPUT_DIR/ingress.txt" 2>&1
kubectl get networkpolicies -n "$NAMESPACE" > "$OUTPUT_DIR/networkpolicies.txt" 2>&1

log_with_timestamp "‚úÖ Debug information collection complete"
log_with_timestamp "üìÅ All files saved to: $OUTPUT_DIR"

# Create summary
cat > "$OUTPUT_DIR/README.md" << README_EOF
# Debug Session Summary

**Date**: $(date)
**Namespace**: $NAMESPACE
**Label Selector**: $APP_LABEL

## Files Generated

- \`cluster-info.txt\` - Cluster information
- \`pods-status.txt\` - Pod status overview
- \`pods-describe.txt\` - Detailed pod descriptions
- \`events.txt\` - Kubernetes events
- \`logs-*-current.txt\` - Current pod logs
- \`logs-*-previous.txt\` - Previous pod logs (if restarted)
- \`resource-usage.txt\` - Resource utilization
- \`services-*.txt\` - Service information

## Quick Analysis Commands

\`\`\`bash
# Find errors in logs
grep -i error $OUTPUT_DIR/logs-*.txt

# Find restarts
grep -i "restart\|killed\|oom" $OUTPUT_DIR/events.txt

# Check resource issues
grep -i "insufficient\|evict\|resource" $OUTPUT_DIR/events.txt $OUTPUT_DIR/pods-describe.txt
\`\`\`
README_EOF

echo "üìä Debug session complete. Check $OUTPUT_DIR/README.md for summary."
EOF

chmod +x debug-kubectl-logs.sh
```

### Advanced Real-Time Monitoring Script
```bash
# Create real-time monitoring script
cat << 'EOF' > monitor-logs-realtime.sh
#!/bin/bash

NAMESPACE=${1:-default}
APP_LABEL=${2:-"app.kubernetes.io/name=my-app"}
DURATION=${3:-300}  # 5 minutes

echo "üì° Starting real-time log monitoring"
echo "Namespace: $NAMESPACE"
echo "Duration: ${DURATION}s"
echo "Press Ctrl+C to stop early"

# Create output files
OUTPUT_DIR="realtime-logs-$(date +%Y%m%d-%H%M%S)"
mkdir -p "$OUTPUT_DIR"

# Function to handle cleanup
cleanup() {
    echo "üõë Stopping monitoring..."
    jobs -p | xargs -r kill 2>/dev/null
    echo "‚úÖ Monitoring stopped. Logs saved to $OUTPUT_DIR"
    exit 0
}

trap cleanup SIGINT SIGTERM

# Start log streaming for each pod
pod_names=$(kubectl get pods -n "$NAMESPACE" -l "$APP_LABEL" -o jsonpath='{.items[*].metadata.name}')

if [ -z "$pod_names" ]; then
    echo "‚ùå No pods found with label: $APP_LABEL"
    exit 1
fi

echo "üöÄ Starting log streams for pods: $pod_names"

pids=()
for pod in $pod_names; do
    echo "üìã Starting stream for pod: $pod"
    
    # Stream all containers
    kubectl logs -f -n "$NAMESPACE" "$pod" --all-containers=true --timestamps=true --prefix=true > "$OUTPUT_DIR/realtime-$pod.log" &
    pids+=($!)
    
    # Stream with error filtering
    kubectl logs -f -n "$NAMESPACE" "$pod" --all-containers=true --timestamps=true | grep -i --line-buffered "error\|warn\|exception\|fail" > "$OUTPUT_DIR/errors-$pod.log" &
    pids+=($!)
done

# Monitor for specific duration
echo "‚è±Ô∏è  Monitoring for ${DURATION} seconds..."

# Background monitoring of pod changes
kubectl get pods -n "$NAMESPACE" -l "$APP_LABEL" --watch > "$OUTPUT_DIR/pod-changes.log" &
pids+=($!)

# Monitor events
kubectl get events -n "$NAMESPACE" --watch > "$OUTPUT_DIR/events-stream.log" &
pids+=($!)

# Wait for duration or interrupt
sleep "$DURATION"

# Stop all background processes
for pid in "${pids[@]}"; do
    kill "$pid" 2>/dev/null || true
done

wait

echo "‚úÖ Real-time monitoring completed"
echo "üìÅ Logs saved to: $OUTPUT_DIR"

# Generate quick summary
echo "üìä Generating summary..."
cat > "$OUTPUT_DIR/summary.txt" << SUMMARY_EOF
Real-time Monitoring Summary
===========================
Start Time: $(date)
Duration: ${DURATION}s
Namespace: $NAMESPACE
Pods Monitored: $pod_names

Error Count by Pod:
$(for pod in $pod_names; do
    if [ -f "$OUTPUT_DIR/errors-$pod.log" ]; then
        count=$(wc -l < "$OUTPUT_DIR/errors-$pod.log")
        echo "  $pod: $count errors"
    fi
done)

Recent Events:
$(tail -10 "$OUTPUT_DIR/events-stream.log" 2>/dev/null || echo "No events captured")
SUMMARY_EOF

cat "$OUTPUT_DIR/summary.txt"
EOF

chmod +x monitor-logs-realtime.sh
```

## üîß Step 3: Interactive Debugging Session

### Interactive Debug Shell
```bash
# Create interactive debugging interface
cat << 'EOF' > interactive-debug.sh
#!/bin/bash

NAMESPACE=${1:-default}
APP_LABEL=${2:-"app.kubernetes.io/name=my-app"}

echo "üêõ Interactive Debugging Session"
echo "================================"
echo "Namespace: $NAMESPACE"
echo "Label Selector: $APP_LABEL"
echo ""

# Get pod list
pods=($(kubectl get pods -n "$NAMESPACE" -l "$APP_LABEL" -o jsonpath='{.items[*].metadata.name}'))

if [ ${#pods[@]} -eq 0 ]; then
    echo "‚ùå No pods found with label: $APP_LABEL"
    exit 1
fi

echo "Available pods:"
for i in "${!pods[@]}"; do
    status=$(kubectl get pod -n "$NAMESPACE" "${pods[$i]}" -o jsonpath='{.status.phase}')
    echo "$((i+1)). ${pods[$i]} ($status)"
done
echo ""

# Main menu
while true; do
    echo "üîç Debug Options:"
    echo "1. View logs (current)"
    echo "2. View logs (previous)"
    echo "3. Stream logs (real-time)"
    echo "4. Describe pod"
    echo "5. Check events"
    echo "6. Execute shell in pod"
    echo "7. Check resource usage"
    echo "8. View environment variables"
    echo "9. Check network connectivity"
    echo "10. Analyze log patterns"
    echo "11. Export debug bundle"
    echo "0. Exit"
    echo ""
    
    read -p "Select option (0-11): " choice
    
    case $choice in
        1)
            echo "Select pod:"
            select pod in "${pods[@]}"; do
                if [ -n "$pod" ]; then
                    echo "üìã Current logs for $pod:"
                    kubectl logs -n "$NAMESPACE" "$pod" --all-containers=true --timestamps=true --tail=100
                    break
                fi
            done
            ;;
        2)
            echo "Select pod:"
            select pod in "${pods[@]}"; do
                if [ -n "$pod" ]; then
                    echo "üìã Previous logs for $pod:"
                    kubectl logs -n "$NAMESPACE" "$pod" --previous --all-containers=true --timestamps=true || echo "No previous logs available"
                    break
                fi
            done
            ;;
        3)
            echo "Select pod:"
            select pod in "${pods[@]}"; do
                if [ -n "$pod" ]; then
                    echo "üì° Streaming logs for $pod (Ctrl+C to stop):"
                    kubectl logs -f -n "$NAMESPACE" "$pod" --all-containers=true --timestamps=true
                    break
                fi
            done
            ;;
        4)
            echo "Select pod:"
            select pod in "${pods[@]}"; do
                if [ -n "$pod" ]; then
                    echo "üîç Pod description for $pod:"
                    kubectl describe pod -n "$NAMESPACE" "$pod"
                    break
                fi
            done
            ;;
        5)
            echo "üìÖ Recent events:"
            kubectl get events -n "$NAMESPACE" --sort-by=.metadata.creationTimestamp | tail -20
            ;;
        6)
            echo "Select pod:"
            select pod in "${pods[@]}"; do
                if [ -n "$pod" ]; then
                    containers=($(kubectl get pod -n "$NAMESPACE" "$pod" -o jsonpath='{.spec.containers[*].name}'))
                    if [ ${#containers[@]} -gt 1 ]; then
                        echo "Select container:"
                        select container in "${containers[@]}"; do
                            if [ -n "$container" ]; then
                                echo "üêö Executing shell in $pod/$container:"
                                kubectl exec -it -n "$NAMESPACE" "$pod" -c "$container" -- /bin/sh || kubectl exec -it -n "$NAMESPACE" "$pod" -c "$container" -- /bin/bash
                                break
                            fi
                        done
                    else
                        echo "üêö Executing shell in $pod:"
                        kubectl exec -it -n "$NAMESPACE" "$pod" -- /bin/sh || kubectl exec -it -n "$NAMESPACE" "$pod" -- /bin/bash
                    fi
                    break
                fi
            done
            ;;
        7)
            echo "üìä Resource usage:"
            kubectl top pods -n "$NAMESPACE" -l "$APP_LABEL" || echo "Metrics server not available"
            echo ""
            echo "Pod resource requests/limits:"
            for pod in "${pods[@]}"; do
                echo "Pod: $pod"
                kubectl get pod -n "$NAMESPACE" "$pod" -o jsonpath='{.spec.containers[*].resources}' | jq . 2>/dev/null || echo "  Raw: $(kubectl get pod -n "$NAMESPACE" "$pod" -o jsonpath='{.spec.containers[*].resources}')"
                echo ""
            done
            ;;
        8)
            echo "Select pod:"
            select pod in "${pods[@]}"; do
                if [ -n "$pod" ]; then
                    echo "üåç Environment variables for $pod:"
                    kubectl exec -n "$NAMESPACE" "$pod" -- env | sort
                    break
                fi
            done
            ;;
        9)
            echo "Select pod:"
            select pod in "${pods[@]}"; do
                if [ -n "$pod" ]; then
                    echo "üåê Network connectivity test for $pod:"
                    echo "Testing DNS resolution:"
                    kubectl exec -n "$NAMESPACE" "$pod" -- nslookup kubernetes.default.svc.cluster.local || echo "nslookup not available"
                    echo "Testing external connectivity:"
                    kubectl exec -n "$NAMESPACE" "$pod" -- ping -c 3 8.8.8.8 || echo "ping not available"
                    echo "Network interfaces:"
                    kubectl exec -n "$NAMESPACE" "$pod" -- ip addr || kubectl exec -n "$NAMESPACE" "$pod" -- ifconfig || echo "Network tools not available"
                    break
                fi
            done
            ;;
        10)
            echo "üîç Analyzing log patterns across all pods:"
            temp_logs=$(mktemp)
            for pod in "${pods[@]}"; do
                kubectl logs -n "$NAMESPACE" "$pod" --all-containers=true --timestamps=true --tail=1000 >> "$temp_logs" 2>/dev/null
            done
            
            echo "Most common log patterns:"
            grep -o '\[.*\] [A-Z]*:' "$temp_logs" | sort | uniq -c | sort -nr | head -10
            echo ""
            echo "Error summary:"
            grep -i "error\|exception\|fail" "$temp_logs" | tail -10
            
            rm "$temp_logs"
            ;;
        11)
            echo "üì¶ Exporting debug bundle..."
            ./debug-kubectl-logs.sh "$NAMESPACE" "$APP_LABEL" "debug-bundle-$(date +%Y%m%d-%H%M%S)"
            ;;
        0)
            echo "üëã Exiting debug session"
            exit 0
            ;;
        *)
            echo "‚ùå Invalid option"
            ;;
    esac
    
    echo ""
    read -p "Press Enter to continue..."
    echo ""
done
EOF

chmod +x interactive-debug.sh
```

## üîé Step 4: Log Pattern Analysis

### Log Pattern Analyzer
```bash
# Create log pattern analysis script
cat << 'EOF' > analyze-log-patterns.sh
#!/bin/bash

NAMESPACE=${1:-default}
APP_LABEL=${2:-"app.kubernetes.io/name=my-app"}
HOURS_BACK=${3:-24}

echo "üìä Log Pattern Analysis"
echo "======================"
echo "Namespace: $NAMESPACE"
echo "Time Range: Last ${HOURS_BACK} hours"

# Collect logs from all pods
temp_dir=$(mktemp -d)
all_logs="$temp_dir/all-logs.txt"

echo "üîç Collecting logs from all pods..."
pod_names=$(kubectl get pods -n "$NAMESPACE" -l "$APP_LABEL" -o jsonpath='{.items[*].metadata.name}')

for pod in $pod_names; do
    echo "  Collecting from $pod..."
    kubectl logs -n "$NAMESPACE" "$pod" --all-containers=true --timestamps=true --since="${HOURS_BACK}h" >> "$all_logs" 2>/dev/null
done

if [ ! -s "$all_logs" ]; then
    echo "‚ùå No logs collected"
    exit 1
fi

echo "üìà Analyzing patterns..."

# 1. Log level distribution
echo "1. Log Level Distribution:"
echo "========================="
grep -o '\] [A-Z]*:' "$all_logs" | sed 's/\] \([A-Z]*\):/\1/' | sort | uniq -c | sort -nr
echo ""

# 2. Most common error messages
echo "2. Top Error Messages:"
echo "====================="
grep -i '\] ERROR:' "$all_logs" | sed 's/.*\] ERROR: \(.*\)/\1/' | sort | uniq -c | sort -nr | head -10
echo ""

# 3. Timeline analysis
echo "3. Log Volume by Hour:"
echo "====================="
grep -o '^[0-9T:-]*' "$all_logs" | sed 's/T/ /' | cut -d' ' -f2 | cut -d: -f1 | sort | uniq -c | sort -k2
echo ""

# 4. Exception analysis
echo "4. Exception Analysis:"
echo "====================="
exceptions=$(grep -i "exception\|stacktrace" "$all_logs" | wc -l)
echo "Total exceptions: $exceptions"
if [ "$exceptions" -gt 0 ]; then
    echo "Exception types:"
    grep -i "exception" "$all_logs" | sed 's/.*\(Exception[^:]*\).*/\1/' | sort | uniq -c | sort -nr | head -5
fi
echo ""

# 5. Performance patterns
echo "5. Performance Indicators:"
echo "=========================="
response_times=$(grep -o 'response_time=[0-9]*' "$all_logs" | cut -d= -f2)
if [ -n "$response_times" ]; then
    echo "Response time statistics:"
    echo "$response_times" | awk '{sum+=$1; if($1>max) max=$1; if(min=="" || $1<min) min=$1; count++} END {print "Average:", sum/count "ms"; print "Max:", max "ms"; print "Min:", min "ms"}'
else
    echo "No response time data found"
fi
echo ""

# 6. Database activity
echo "6. Database Activity:"
echo "===================="
db_queries=$(grep -i "database\|sql\|query" "$all_logs" | wc -l)
echo "Database-related log entries: $db_queries"
if [ "$db_queries" -gt 0 ]; then
    echo "Database operations:"
    grep -i "database\|sql\|query" "$all_logs" | grep -o -i 'SELECT\|INSERT\|UPDATE\|DELETE' | sort | uniq -c | sort -nr
fi
echo ""

# 7. Security events
echo "7. Security Events:"
echo "=================="
security_events=$(grep -i "auth\|login\|security\|permission\|denied" "$all_logs" | wc -l)
echo "Security-related events: $security_events"
if [ "$security_events" -gt 0 ]; then
    echo "Recent security events:"
    grep -i "auth\|login\|security\|permission\|denied" "$all_logs" | tail -5
fi
echo ""

# 8. Resource usage indicators
echo "8. Resource Usage Indicators:"
echo "============================"
memory_warnings=$(grep -i "memory\|oom" "$all_logs" | wc -l)
cpu_warnings=$(grep -i "cpu\|throttle" "$all_logs" | wc -l)
echo "Memory-related warnings: $memory_warnings"
echo "CPU-related warnings: $cpu_warnings"
echo ""

# 9. Application lifecycle events
echo "9. Application Lifecycle:"
echo "========================"
starts=$(grep -i "start\|init" "$all_logs" | wc -l)
shutdowns=$(grep -i "shutdown\|stop\|exit" "$all_logs" | wc -l)
echo "Application starts: $starts"
echo "Application shutdowns: $shutdowns"
echo ""

# 10. Health check analysis
echo "10. Health Check Analysis:"
echo "========================="
health_checks=$(grep -i "health\|ready" "$all_logs" | wc -l)
echo "Health check entries: $health_checks"
if [ "$health_checks" -gt 0 ]; then
    echo "Health check status distribution:"
    grep -i "health\|ready" "$all_logs" | grep -o -i "200\|404\|500\|503" | sort | uniq -c | sort -nr
fi

# Generate summary report
cat > "log-analysis-report-$(date +%Y%m%d-%H%M%S).txt" << REPORT_EOF
Log Pattern Analysis Report
===========================
Date: $(date)
Namespace: $NAMESPACE
Time Range: Last ${HOURS_BACK} hours
Total Log Lines: $(wc -l < "$all_logs")

Summary:
- Pods Analyzed: $(echo "$pod_names" | wc -w)
- Total Exceptions: $exceptions
- Security Events: $security_events  
- Memory Warnings: $memory_warnings
- CPU Warnings: $cpu_warnings
- Health Checks: $health_checks

Recommendations:
$(if [ "$exceptions" -gt 10 ]; then echo "- High exception rate detected - investigate error patterns"; fi)
$(if [ "$memory_warnings" -gt 0 ]; then echo "- Memory warnings found - check resource limits"; fi)
$(if [ "$security_events" -gt 0 ]; then echo "- Security events detected - review authentication logs"; fi)

Full analysis available in temporary files:
$temp_dir/all-logs.txt
REPORT_EOF

echo "üìä Analysis complete. Report saved as: log-analysis-report-$(date +%Y%m%d-%H%M%S).txt"

# Cleanup
rm -rf "$temp_dir"
EOF

chmod +x analyze-log-patterns.sh
```

## üö® Step 5: Automated Issue Detection

### Issue Detection Script
```bash
# Create automated issue detection script
cat << 'EOF' > detect-issues.sh
#!/bin/bash

NAMESPACE=${1:-default}
APP_LABEL=${2:-"app.kubernetes.io/name=my-app"}

echo "üö® Automated Issue Detection"
echo "============================="

issues_found=0
temp_dir=$(mktemp -d)

# Function to report issues
report_issue() {
    local severity=$1
    local issue=$2
    local details=$3
    
    echo "[$severity] $issue"
    if [ -n "$details" ]; then
        echo "    Details: $details"
    fi
    echo ""
    issues_found=$((issues_found + 1))
}

echo "üîç Scanning for issues..."

# 1. Check pod status
echo "1. Checking pod health..."
unhealthy_pods=$(kubectl get pods -n "$NAMESPACE" -l "$APP_LABEL" --no-headers | grep -v "Running\|Completed" | wc -l)
if [ "$unhealthy_pods" -gt 0 ]; then
    pod_issues=$(kubectl get pods -n "$NAMESPACE" -l "$APP_LABEL" --no-headers | grep -v "Running\|Completed")
    report_issue "CRITICAL" "Unhealthy pods detected" "$pod_issues"
fi

# 2. Check for restarts
echo "2. Checking for recent restarts..."
restarted_pods=$(kubectl get pods -n "$NAMESPACE" -l "$APP_LABEL" -o jsonpath='{range .items[*]}{.metadata.name}{" "}{.status.containerStatuses[*].restartCount}{"\n"}{end}' | awk '$2 > 0')
if [ -n "$restarted_pods" ]; then
    report_issue "WARNING" "Pods with restarts detected" "$restarted_pods"
fi

# 3. Check recent logs for errors
echo "3. Analyzing recent logs for errors..."
pod_names=$(kubectl get pods -n "$NAMESPACE" -l "$APP_LABEL" -o jsonpath='{.items[*].metadata.name}')
error_logs="$temp_dir/error-logs.txt"

for pod in $pod_names; do
    kubectl logs -n "$NAMESPACE" "$pod" --since=1h --all-containers=true 2>/dev/null | grep -i "error\|exception\|fatal" >> "$error_logs"
done

if [ -s "$error_logs" ]; then
    error_count=$(wc -l < "$error_logs")
    if [ "$error_count" -gt 10 ]; then
        recent_errors=$(tail -5 "$error_logs")
        report_issue "HIGH" "High error rate in logs ($error_count errors in last hour)" "$recent_errors"
    elif [ "$error_count" -gt 0 ]; then
        recent_errors=$(tail -3 "$error_logs")
        report_issue "MEDIUM" "Errors found in logs ($error_count errors in last hour)" "$recent_errors"
    fi
fi

# 4. Check resource usage
echo "4. Checking resource usage..."
resource_issues=$(kubectl top pods -n "$NAMESPACE" -l "$APP_LABEL" 2>/dev/null | awk 'NR>1 && ($2>1000 || $3>1000) {print $1 ": CPU " $2 ", Memory " $3}')
if [ -n "$resource_issues" ]; then
    report_issue "MEDIUM" "High resource usage detected" "$resource_issues"
fi

# 5. Check events for issues
echo "5. Checking events for issues..."
warning_events=$(kubectl get events -n "$NAMESPACE" --field-selector type=Warning --since=1h --no-headers 2>/dev/null | wc -l)
if [ "$warning_events" -gt 5 ]; then
    recent_warnings=$(kubectl get events -n "$NAMESPACE" --field-selector type=Warning --since=1h --no-headers | tail -3 | awk '{print $6 ": " $7}')
    report_issue "MEDIUM" "Multiple warning events ($warning_events in last hour)" "$recent_warnings"
fi

# 6. Check for OOM kills
echo "6. Checking for OOM kills..."
oom_events=$(kubectl get events -n "$NAMESPACE" --since=24h --no-headers 2>/dev/null | grep -i "oomkill\|out of memory")
if [ -n "$oom_events" ]; then
    report_issue "HIGH" "OOM (Out of Memory) events detected" "$oom_events"
fi

# 7. Check network connectivity
echo "7. Checking network connectivity..."
for pod in $pod_names; do
    # Check if pod can reach DNS
    dns_check=$(kubectl exec -n "$NAMESPACE" "$pod" -- nslookup kubernetes.default.svc.cluster.local 2>&1 | grep -c "server can't find" || true)
    if [ "$dns_check" -gt 0 ]; then
        report_issue "HIGH" "DNS resolution issues in pod $pod"
    fi
done

# 8. Check disk space (if possible)
echo "8. Checking disk space..."
for pod in $pod_names; do
    disk_usage=$(kubectl exec -n "$NAMESPACE" "$pod" -- df -h 2>/dev/null | awk '$5 > 90 {print $1 ": " $5}' || true)
    if [ -n "$disk_usage" ]; then
        report_issue "MEDIUM" "High disk usage in pod $pod" "$disk_usage"
    fi
done

# 9. Check service endpoints
echo "9. Checking service endpoints..."
services=$(kubectl get services -n "$NAMESPACE" -l "$APP_LABEL" -o jsonpath='{.items[*].metadata.name}')
for service in $services; do
    endpoints=$(kubectl get endpoints -n "$NAMESPACE" "$service" -o jsonpath='{.subsets[*].addresses[*].ip}' | wc -w)
    if [ "$endpoints" -eq 0 ]; then
        report_issue "CRITICAL" "Service $service has no endpoints"
    fi
done

# 10. Check ingress issues
echo "10. Checking ingress configuration..."
ingresses=$(kubectl get ingress -n "$NAMESPACE" -o jsonpath='{.items[*].metadata.name}')
for ingress in $ingresses; do
    backends=$(kubectl get ingress -n "$NAMESPACE" "$ingress" -o jsonpath='{.status.loadBalancer.ingress}')
    if [ -z "$backends" ]; then
        report_issue "WARNING" "Ingress $ingress has no load balancer assigned"
    fi
done

# Generate summary
echo "üéØ ISSUE DETECTION SUMMARY"
echo "=========================="
if [ "$issues_found" -eq 0 ]; then
    echo "‚úÖ No issues detected - system appears healthy"
else
    echo "‚ö†Ô∏è  Found $issues_found potential issues"
    echo ""
    echo "Recommended actions:"
    echo "1. Review the issues listed above"
    echo "2. Check detailed logs: ./debug-kubectl-logs.sh $NAMESPACE '$APP_LABEL'"
    echo "3. Monitor in real-time: ./monitor-logs-realtime.sh $NAMESPACE '$APP_LABEL'"
    echo "4. Run interactive debug: ./interactive-debug.sh $NAMESPACE '$APP_LABEL'"
fi

# Cleanup
rm -rf "$temp_dir"

# Return exit code based on critical issues
critical_issues=$(grep -c "CRITICAL" <<< "$issues_found" || true)
if [ "$critical_issues" -gt 0 ]; then
    exit 2
elif [ "$issues_found" -gt 0 ]; then
    exit 1
else
    exit 0
fi
EOF

chmod +x detect-issues.sh
```

## üîÑ Step 6: Integration with External Monitoring

### CloudWatch Integration Script
```bash
# Create CloudWatch integration for kubectl logs
cat << 'EOF' > kubectl-cloudwatch-integration.sh
#!/bin/bash

NAMESPACE=${1:-default}
APP_LABEL=${2:-"app.kubernetes.io/name=my-app"}
LOG_GROUP=${3:-"/aws/containerinsights/my-cluster/application"}
REGION=${4:-"us-west-2"}

echo "üîó kubectl Logs + CloudWatch Integration"
echo "========================================"

# Function to correlate kubectl logs with CloudWatch
correlate_logs() {
    local pod_name=$1
    local time_range=$2
    
    echo "üîç Correlating logs for pod: $pod_name"
    echo "Time range: $time_range"
    
    # Get kubectl logs
    echo "üìã Local kubectl logs:"
    kubectl logs -n "$NAMESPACE" "$pod_name" --since="$time_range" --timestamps=true | head -20
    
    # Get CloudWatch logs
    echo "‚òÅÔ∏è  CloudWatch logs:"
    start_time=$(date -d "$time_range ago" +%s)
    end_time=$(date +%s)
    
    # Start CloudWatch query
    query_id=$(aws logs start-query \
        --log-group-name "$LOG_GROUP" \
        --start-time "$start_time" \
        --end-time "$end_time" \
        --query-string "fields @timestamp, @message | filter kubernetes.pod_name = \"$pod_name\" | sort @timestamp desc | limit 20" \
        --region "$REGION" \
        --query 'queryId' \
        --output text 2>/dev/null)
    
    if [ -n "$query_id" ]; then
        echo "Waiting for CloudWatch query results..."
        sleep 5
        
        aws logs get-query-results \
            --query-id "$query_id" \
            --region "$REGION" \
            --query 'results' \
            --output table 2>/dev/null || echo "CloudWatch query failed"
    else
        echo "CloudWatch not available or no logs found"
    fi
    
    echo ""
}

# Function to send kubectl findings to CloudWatch as custom metrics
send_metrics_to_cloudwatch() {
    local metric_name=$1
    local value=$2
    local unit=${3:-"Count"}
    
    aws cloudwatch put-metric-data \
        --namespace "Kubectl/Debugging" \
        --metric-data MetricName="$metric_name",Value="$value",Unit="$unit" \
        --region "$REGION" 2>/dev/null || echo "Failed to send metric: $metric_name"
}

echo "üîç Starting correlation analysis..."

# Get pod list
pod_names=$(kubectl get pods -n "$NAMESPACE" -l "$APP_LABEL" -o jsonpath='{.items[*].metadata.name}')

if [ -z "$pod_names" ]; then
    echo "‚ùå No pods found"
    exit 1
fi

# Analyze each pod
for pod in $pod_names; do
    echo "=============================================="
    correlate_logs "$pod" "1h"
    
    # Get error count from kubectl logs
    error_count=$(kubectl logs -n "$NAMESPACE" "$pod" --since=1h | grep -c -i "error" || echo "0")
    send_metrics_to_cloudwatch "ErrorCount" "$error_count"
    
    # Get restart count
    restart_count=$(kubectl get pod -n "$NAMESPACE" "$pod" -o jsonpath='{.status.containerStatuses[0].restartCount}')
    send_metrics_to_cloudwatch "RestartCount" "$restart_count"
done

# Create unified view script
cat > "unified-log-viewer-$(date +%Y%m%d-%H%M%S).sh" << VIEWER_EOF
#!/bin/bash
# Unified log viewer combining kubectl and CloudWatch

NAMESPACE="$NAMESPACE"
APP_LABEL="$APP_LABEL"
LOG_GROUP="$LOG_GROUP"
REGION="$REGION"

echo "üîó Unified Log Viewer"
echo "===================="

# Select time range
echo "Select time range:"
echo "1. Last 15 minutes"
echo "2. Last 1 hour" 
echo "3. Last 4 hours"
echo "4. Last 24 hours"
read -p "Choice (1-4): " time_choice

case \$time_choice in
    1) time_range="15m" ;;
    2) time_range="1h" ;;
    3) time_range="4h" ;;
    4) time_range="24h" ;;
    *) time_range="1h" ;;
esac

# View combined logs
echo "üìä Viewing logs from last \$time_range"

echo "--- kubectl logs ---"
kubectl logs -n "\$NAMESPACE" -l "\$APP_LABEL" --since="\$time_range" --timestamps=true --prefix=true | tail -20

echo "--- CloudWatch logs ---"
./run-insights-query.sh "\$LOG_GROUP" "fields @timestamp, @message | filter kubernetes.namespace = '\$NAMESPACE' | sort @timestamp desc | limit 20" "-\$time_range"
VIEWER_EOF

chmod +x "unified-log-viewer-$(date +%Y%m%d-%H%M%S).sh"

echo "‚úÖ Integration complete"
echo "üìä Metrics sent to CloudWatch namespace: Kubectl/Debugging"
echo "üîó Unified viewer script created"
EOF

chmod +x kubectl-cloudwatch-integration.sh
```

## ‚ö° Step 7: Run Complete Debugging Session

### Execute Debugging Workflow
```bash
# Use our created scripts to debug the application
echo "üöÄ Starting complete debugging workflow"

# Step 1: Detect issues automatically
echo "=== Step 1: Automated Issue Detection ==="
./detect-issues.sh development-kustomize "app.kubernetes.io/name=my-app"

# Step 2: Collect comprehensive debug information
echo "=== Step 2: Debug Information Collection ==="
./debug-kubectl-logs.sh development-kustomize "app.kubernetes.io/name=my-app"

# Step 3: Analyze log patterns
echo "=== Step 3: Log Pattern Analysis ==="
./analyze-log-patterns.sh development-kustomize "app.kubernetes.io/name=my-app" 2

# Step 4: Start real-time monitoring (background)
echo "=== Step 4: Real-time Monitoring (30 seconds) ==="
timeout 30 ./monitor-logs-realtime.sh development-kustomize "app.kubernetes.io/name=my-app" 30 &

# Step 5: Integration test (if CloudWatch is available)
echo "=== Step 5: CloudWatch Integration Test ==="
./kubectl-cloudwatch-integration.sh development-kustomize "app.kubernetes.io/name=my-app" 2>/dev/null || echo "CloudWatch integration skipped"

# Wait for background monitoring to complete
wait

echo "‚úÖ Complete debugging workflow finished"
echo "üìÅ Check generated directories and files for detailed results"
```

## ‚úÖ Success Criteria

### ‚úÖ Debugging Setup Checklist
- [ ] Basic kubectl logs commands mastered
- [ ] Comprehensive debugging script created and tested
- [ ] Real-time monitoring script functional
- [ ] Interactive debugging interface working
- [ ] Log pattern analysis script operational
- [ ] Automated issue detection script created
- [ ] CloudWatch integration implemented (if available)
- [ ] All scripts generate useful output
- [ ] Debug workflows documented and tested

### ‚úÖ Validation Commands
```bash
# All these should work and provide useful output:
kubectl logs -n development-kustomize -l "app.kubernetes.io/name=my-app" --tail=5
./debug-kubectl-logs.sh development-kustomize "app.kubernetes.io/name=my-app"
./detect-issues.sh development-kustomize "app.kubernetes.io/name=my-app"
./analyze-log-patterns.sh development-kustomize "app.kubernetes.io/name=my-app" 1
```

## üéØ Troubleshooting Common Issues

### Quick Issue Resolution Guide
```bash
# Create quick troubleshooting guide
cat << 'EOF' > quick-troubleshoot.md
# Quick Troubleshooting Guide

## üö® Pod Crashes/Restarts
```bash
# Check recent events
kubectl get events --sort-by=.metadata.creationTimestamp | tail -10

# Check pod status and restarts
kubectl get pods -o wide

# Get crash logs
kubectl logs <pod-name> --previous
```

## üîå Network Issues
```bash
# Test DNS resolution
kubectl exec <pod-name> -- nslookup kubernetes.default.svc.cluster.local

# Check service endpoints
kubectl get endpoints

# Test service connectivity
kubectl exec <pod-name> -- curl -v <service-name>:<port>
```

## üíæ Resource Issues
```bash
# Check resource usage
kubectl top nodes
kubectl top pods

# Check resource limits
kubectl describe pod <pod-name> | grep -A 5 "Limits\|Requests"

# Check for OOM kills
kubectl get events | grep -i oom
```

## üìù Configuration Issues
```bash
# Check environment variables
kubectl exec <pod-name> -- env

# Verify mounted volumes
kubectl describe pod <pod-name> | grep -A 10 "Volumes\|Mounts"

# Check ConfigMaps and Secrets
kubectl get configmaps,secrets
```

## üîÑ Application Issues
```bash
# Check application logs for errors
kubectl logs <pod-name> | grep -i error

# Check health endpoints
kubectl exec <pod-name> -- curl localhost:8080/health

# Verify application process
kubectl exec <pod-name> -- ps aux
```
EOF

echo "üìö Quick troubleshooting guide created"
```

## üéì Key Takeaways

### What You've Learned
1. **kubectl Logs Mastery**: Complete command variations and options for log retrieval
2. **Automated Debugging**: Scripts for comprehensive debug information collection
3. **Pattern Analysis**: Systematic log analysis for issue identification
4. **Real-time Monitoring**: Live log streaming and monitoring techniques
5. **Issue Detection**: Automated detection of common Kubernetes issues
6. **Integration**: Combining kubectl logs with external monitoring systems

### Best Practices Implemented
- Structured debugging workflows
- Automated issue detection and reporting
- Comprehensive log collection and analysis
- Real-time monitoring capabilities
- Integration with external monitoring systems
- Documentation and playbook creation

This comprehensive debugging toolkit provides everything needed to effectively troubleshoot Kubernetes applications using kubectl logs and related tools.

## üèÜ Congratulations!

You've successfully completed all 6 practice exercises, mastering:

1. ‚úÖ **Helm Deployment** - Complete application deployment with environment-specific configurations
2. ‚úÖ **ConfigMap Management** - Dynamic configuration updates using kubectl
3. ‚úÖ **Helm Upgrades** - Safe upgrade procedures with rollback capabilities
4. ‚úÖ **Kustomize Integration** - Environment-specific configurations with overlay patterns
5. ‚úÖ **CloudWatch Monitoring** - Comprehensive logging and monitoring setup
6. ‚úÖ **kubectl Debugging** - Advanced troubleshooting and log analysis techniques

You now have the practical skills to deploy, manage, monitor, and troubleshoot Kubernetes applications effectively using the complete DevOps toolkit!