# 4. Strategic Merge Patches vs JSON Patches

## ğŸ¯ Learning Objectives
- [ ] Understand the difference between Strategic Merge Patches and JSON Patches
- [ ] Learn when to use each patching method
- [ ] Master Strategic Merge Patch syntax and merge strategies
- [ ] Practice JSON Patch operations and targeting
- [ ] Implement complex patching scenarios for different use cases

## ğŸ“‹ Patching Overview

### Patch Types Comparison
```yaml
Strategic Merge Patch:
âœ… Kubernetes-native merge logic
âœ… Field-aware merging (lists, maps)
âœ… Simple YAML syntax
âœ… Intuitive for Kubernetes resources
âŒ Limited to supported fields
âŒ Less precise control

JSON Patch (RFC 6902):
âœ… Precise control over changes
âœ… Works with any JSON document
âœ… Add, remove, replace, copy, move, test operations
âœ… Supports complex path expressions
âŒ More complex syntax
âŒ Requires exact path knowledge
```

### When to Use Each Type
```
Use Strategic Merge Patch for:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â€¢ Adding/modifying container env vars   â”‚
â”‚ â€¢ Updating resource limits/requests     â”‚
â”‚ â€¢ Adding labels and annotations         â”‚
â”‚ â€¢ Modifying deployment strategy         â”‚
â”‚ â€¢ Adding volumes and volume mounts      â”‚
â”‚ â€¢ Simple field updates                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Use JSON Patch for:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â€¢ Precise array element operations      â”‚
â”‚ â€¢ Conditional modifications             â”‚
â”‚ â€¢ Complex field manipulations           â”‚
â”‚ â€¢ Unsupported merge strategies          â”‚
â”‚ â€¢ Custom resource modifications         â”‚
â”‚ â€¢ Advanced transformation logic         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ› ï¸ Strategic Merge Patches

### Basic Strategic Merge Syntax
```yaml
# kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - deployment.yaml

patches:
  - path: deployment-patch.yaml
    target:
      kind: Deployment
      name: webapp

# Alternative syntax (deprecated but still supported)
patchesStrategicMerge:
  - deployment-patch.yaml
```

### Simple Strategic Merge Examples
```yaml
# Original deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
  labels:
    app: webapp
spec:
  replicas: 2
  template:
    spec:
      containers:
      - name: webapp
        image: webapp:v1.0.0
        env:
        - name: ENV
          value: production
        resources:
          requests:
            cpu: 100m
            memory: 128Mi

---
# deployment-patch.yaml (Strategic Merge)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
  labels:
    environment: staging        # Adds new label
  annotations:
    deployment.kubernetes.io/revision: "2"  # Adds annotation
spec:
  replicas: 5                   # Replaces replica count
  template:
    spec:
      containers:
      - name: webapp
        image: webapp:v2.0.0      # Replaces image
        env:
        - name: ENV
          value: staging          # Replaces existing env var
        - name: DEBUG             # Adds new env var
          value: "true"
        resources:
          requests:
            cpu: 200m             # Updates CPU request
            memory: 128Mi         # Memory unchanged (merged)
          limits:                 # Adds new limits section
            cpu: 500m
            memory: 512Mi
```

### Container-Level Patching
```yaml
# Multi-container deployment patching
# deployment-multi-patch.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  template:
    spec:
      containers:
      - name: webapp              # Targets specific container by name
        image: webapp:v2.1.0
        env:
        - name: DATABASE_URL
          value: postgresql://new-db:5432/webapp
        resources:
          limits:
            cpu: 1000m
      - name: sidecar             # Targets different container
        image: sidecar:v1.2.0
        env:
        - name: SIDECAR_MODE
          value: production
      initContainers:             # Adds init containers
      - name: init-db
        image: init-db:latest
        command: ['sh', '-c', 'echo Initializing database']
```

### Volume and Mount Patching
```yaml
# volume-patch.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  template:
    spec:
      containers:
      - name: webapp
        volumeMounts:
        - name: config-volume     # Adds new volume mount
          mountPath: /app/config
        - name: data-volume       # Adds another mount
          mountPath: /app/data
      volumes:
      - name: config-volume       # Adds new volume
        configMap:
          name: webapp-config
      - name: data-volume         # Adds persistent volume
        persistentVolumeClaim:
          claimName: webapp-data
```

### Service and Ingress Patching
```yaml
# service-patch.yaml
apiVersion: v1
kind: Service
metadata:
  name: webapp-service
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: nlb
spec:
  type: LoadBalancer            # Changes service type
  ports:
  - port: 80
    targetPort: 8080
  - port: 443                   # Adds HTTPS port
    targetPort: 8443
    name: https

---
# ingress-patch.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: webapp-ingress
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    cert-manager.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
  - hosts:
    - webapp.company.com
    secretName: webapp-tls
  rules:
  - host: webapp.company.com
    http:
      paths:
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: webapp-service
            port:
              number: 80
```

## ğŸ¯ JSON Patches (RFC 6902)

### JSON Patch Operations
```yaml
# kustomization.yaml with JSON patches
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - deployment.yaml

patches:
  - path: json-patch.yaml
    target:
      kind: Deployment
      name: webapp

# Alternative syntax
patchesJson6902:
  - target:
      version: v1
      kind: Deployment
      name: webapp
    path: json-patch.yaml
```

### JSON Patch Operations Reference
```yaml
# json-patch.yaml
# All JSON Patch operations with examples

# 1. ADD operation - adds new values
- op: add
  path: /metadata/labels/environment
  value: production

- op: add
  path: /spec/template/spec/containers/0/env/-  # Add to end of array
  value:
    name: NEW_VAR
    value: new_value

# 2. REPLACE operation - replaces existing values
- op: replace
  path: /spec/replicas
  value: 5

- op: replace
  path: /spec/template/spec/containers/0/image
  value: webapp:v2.0.0

# 3. REMOVE operation - removes existing values
- op: remove
  path: /spec/template/spec/containers/0/env/2  # Remove 3rd env var

- op: remove
  path: /metadata/annotations/old-annotation

# 4. MOVE operation - moves values
- op: move
  from: /metadata/labels/app
  path: /metadata/labels/application

# 5. COPY operation - copies values
- op: copy
  from: /spec/template/spec/containers/0/resources/requests/cpu
  path: /spec/template/spec/containers/0/resources/limits/cpu

# 6. TEST operation - validates existing values
- op: test
  path: /spec/replicas
  value: 2  # Fails if replicas is not 2
```

### Complex JSON Patch Scenarios
```yaml
# complex-json-patch.yaml
# Scenario: Update specific container in multi-container pod

# Find and update webapp container specifically
- op: test
  path: /spec/template/spec/containers/0/name
  value: webapp  # Ensure we're targeting the right container

- op: replace
  path: /spec/template/spec/containers/0/image
  value: webapp:v3.0.0

# Add environment variable to webapp container
- op: add
  path: /spec/template/spec/containers/0/env/-
  value:
    name: FEATURE_FLAG_NEW_UI
    value: "true"

# Update sidecar container (assuming it's the second container)
- op: test
  path: /spec/template/spec/containers/1/name
  value: sidecar

- op: replace
  path: /spec/template/spec/containers/1/resources/limits/memory
  value: 256Mi

# Add init container at the beginning
- op: add
  path: /spec/template/spec/initContainers
  value:
    - name: init-permissions
      image: busybox:1.35
      command: ['chmod', '-R', '755', '/shared']
      volumeMounts:
      - name: shared-data
        mountPath: /shared

# Conditional patching based on existing values
- op: test
  path: /metadata/labels/app
  value: webapp

- op: add
  path: /metadata/labels/version
  value: v3.0.0
```

### Array Manipulation with JSON Patches
```yaml
# array-operations.yaml
# Working with Kubernetes arrays (env vars, ports, volumes)

# Add environment variable at specific position
- op: add
  path: /spec/template/spec/containers/0/env/1  # Insert at index 1
  value:
    name: INSERTED_VAR
    value: inserted_value

# Add to end of array
- op: add
  path: /spec/template/spec/containers/0/env/-
  value:
    name: LAST_VAR
    value: last_value

# Replace specific array element
- op: replace
  path: /spec/template/spec/containers/0/ports/0
  value:
    containerPort: 8443
    protocol: TCP
    name: https

# Remove specific array element
- op: remove
  path: /spec/template/spec/containers/0/env/2

# Move array elements
- op: move
  from: /spec/template/spec/containers/0/env/0
  path: /spec/template/spec/containers/0/env/2

# Add volume mount
- op: add
  path: /spec/template/spec/containers/0/volumeMounts/-
  value:
    name: secret-volume
    mountPath: /etc/secrets
    readOnly: true

# Add corresponding volume
- op: add
  path: /spec/template/spec/volumes/-
  value:
    name: secret-volume
    secret:
      secretName: webapp-secrets
```

## ğŸ”€ Advanced Patching Patterns

### Conditional Patching with JSON
```yaml
# conditional-patch.yaml
# Use test operations to make patches conditional

# Only add debug env var if not already present
- op: test
  path: /spec/template/spec/containers/0/env
  value: []  # Test will fail if env exists, so this patch won't apply

- op: add
  path: /spec/template/spec/containers/0/env
  value:
    - name: DEBUG
      value: "true"

# Alternative approach - test for specific conditions
- op: test
  path: /metadata/labels/environment
  value: development

- op: add
  path: /spec/template/spec/containers/0/env/-
  value:
    name: DEV_MODE
    value: "true"
```

### Multi-Target Patching
```yaml
# kustomization.yaml - patch multiple resources
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - deployment.yaml
  - service.yaml
  - ingress.yaml

patches:
  # Strategic merge patches for different resources
  - path: deployment-patch.yaml
    target:
      kind: Deployment
      name: webapp
  
  - path: service-patch.yaml
    target:
      kind: Service
      name: webapp-service
  
  # JSON patches for precise control
  - path: ingress-json-patch.yaml
    target:
      kind: Ingress
      name: webapp-ingress
```

### Patch Targeting with Selectors
```yaml
# kustomization.yaml - advanced targeting
patches:
  # Target by name and kind
  - path: resource-patch.yaml
    target:
      kind: Deployment
      name: webapp
  
  # Target by label selector
  - path: label-patch.yaml
    target:
      kind: Deployment
      labelSelector: app=webapp,tier=backend
  
  # Target by annotation selector
  - path: annotation-patch.yaml
    target:
      kind: Service
      annotationSelector: service-type=public
  
  # Target by namespace
  - path: namespace-patch.yaml
    target:
      kind: ConfigMap
      namespace: production
  
  # Target multiple kinds
  - path: multi-kind-patch.yaml
    target:
      kind: Deployment|Service
      name: webapp.*  # Regex pattern
```

## ğŸ§ª Patching Best Practices

### Strategic Merge Best Practices
```yaml
# âœ… DO: Use strategic merge for simple modifications
# deployment-simple-patch.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 3
  template:
    spec:
      containers:
      - name: webapp
        resources:
          limits:
            memory: 1Gi

# âœ… DO: Leverage merge key strategies
# List merge strategies for different fields:
# env vars: merge by name
# ports: merge by containerPort
# volumeMounts: merge by mountPath
# volumes: merge by name

# âŒ DON'T: Use strategic merge for complex array operations
# Instead use JSON patches for precise array control
```

### JSON Patch Best Practices
```yaml
# âœ… DO: Use test operations for safety
- op: test
  path: /spec/replicas
  value: 2  # Ensure current state before patching

- op: replace
  path: /spec/replicas
  value: 5

# âœ… DO: Group related operations
# Update container image and related env vars together
- op: replace
  path: /spec/template/spec/containers/0/image
  value: webapp:v2.0.0

- op: add
  path: /spec/template/spec/containers/0/env/-
  value:
    name: APP_VERSION
    value: v2.0.0

# âŒ DON'T: Make assumptions about array indices
# Array indices can change, use name-based targeting when possible
```

### Environment-Specific Patching
```yaml
# overlays/development/kustomization.yaml
patches:
  - path: dev-resources.yaml
    target:
      kind: Deployment
      name: webapp

# overlays/production/kustomization.yaml
patches:
  - path: prod-resources.yaml
    target:
      kind: Deployment
      name: webapp
  - path: prod-security.yaml
    target:
      kind: Deployment
      name: webapp
```

## ğŸ“ Practical Examples

### Example 1: Development vs Production Patches
```yaml
# overlays/dev/dev-patch.yaml (Strategic Merge)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
  labels:
    environment: development
spec:
  replicas: 1
  template:
    spec:
      containers:
      - name: webapp
        image: webapp:dev-latest
        env:
        - name: LOG_LEVEL
          value: DEBUG
        - name: HOT_RELOAD
          value: "true"
        resources:
          requests:
            cpu: 50m
            memory: 64Mi

# overlays/prod/prod-patch.json (JSON Patch)
[
  {
    "op": "replace",
    "path": "/metadata/labels/environment",
    "value": "production"
  },
  {
    "op": "replace",
    "path": "/spec/replicas",
    "value": 5
  },
  {
    "op": "replace",
    "path": "/spec/template/spec/containers/0/image",
    "value": "webapp:v1.2.3"
  },
  {
    "op": "add",
    "path": "/spec/template/spec/containers/0/env/-",
    "value": {
      "name": "PRODUCTION_MODE",
      "value": "true"
    }
  }
]
```

### Example 2: Feature Flag Management
```yaml
# feature-flags-patch.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  template:
    spec:
      containers:
      - name: webapp
        env:
        - name: FEATURE_NEW_UI
          value: "true"
        - name: FEATURE_ANALYTICS
          value: "false"
        - name: FEATURE_RECOMMENDATIONS
          value: "true"

# Corresponding JSON patch for precise control
# feature-flags.json
[
  {
    "op": "test",
    "path": "/spec/template/spec/containers/0/name",
    "value": "webapp"
  },
  {
    "op": "add",
    "path": "/spec/template/spec/containers/0/env/-",
    "value": {
      "name": "FEATURE_BETA_ACCESS",
      "value": "enabled"
    }
  }
]
```

### Example 3: Security Hardening Patches
```yaml
# security-patch.yaml (Strategic Merge)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  template:
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 2000
      containers:
      - name: webapp
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
        resources:
          limits:
            cpu: 1000m
            memory: 1Gi
        volumeMounts:
        - name: tmp-volume
          mountPath: /tmp
      volumes:
      - name: tmp-volume
        emptyDir: {}
```

## ğŸ” Testing and Validation

### Testing Patches
```bash
# Test strategic merge patches
kubectl kustomize overlays/dev | grep -A 10 "kind: Deployment"

# Test JSON patches
kubectl kustomize overlays/prod | yq e '.spec.replicas' -

# Validate patch application
kubectl apply -k overlays/dev --dry-run=client -o yaml | grep replicas

# Compare before and after
diff <(kubectl kustomize base) <(kubectl kustomize overlays/dev)
```

### Debugging Patch Issues
```bash
# Debug strategic merge issues
kubectl kustomize . --dry-run=client -v=5

# Debug JSON patch issues
kubectl kustomize . 2>&1 | grep -i "json patch"

# Validate JSON patch syntax
cat json-patch.yaml | jq '.' > /dev/null && echo "Valid JSON"
```

## ğŸ¯ Quick Reference

### Strategic Merge Patch Template
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: target-deployment
  labels:
    new-label: value
spec:
  replicas: 3
  template:
    spec:
      containers:
      - name: container-name
        image: new-image:tag
        env:
        - name: NEW_ENV
          value: new-value
```

### JSON Patch Operations Template
```yaml
- op: add|replace|remove|move|copy|test
  path: /path/to/field
  value: new-value        # For add/replace/test
  from: /source/path      # For move/copy
```

## â¡ï¸ Next Steps
Now that you understand both patching mechanisms, proceed to [5. Creating-Environment-Specific-Overlays.md](5.%20Creating-Environment-Specific-Overlays.md) to learn how to create comprehensive environment-specific configurations for dev, staging, and production deployments.