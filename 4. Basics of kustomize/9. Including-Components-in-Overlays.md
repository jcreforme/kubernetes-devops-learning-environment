# 9. Including Components in Overlays

## ğŸ¯ Learning Objectives
- [ ] Master component integration in overlay configurations
- [ ] Understand component dependency management and resolution
- [ ] Implement environment-specific component customization
- [ ] Handle component conflicts and precedence rules
- [ ] Build complex multi-component overlay architectures

## ğŸ—ï¸ Component Integration Architecture

### Understanding Component Inclusion Flow
```
Component Resolution Order:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Base Resources    â”‚ Foundation application resources      â”‚
â”‚ 2. Components        â”‚ Additional functionality modules      â”‚
â”‚ 3. Overlay Resources â”‚ Environment-specific additions       â”‚
â”‚ 4. Patches           â”‚ Modifications to existing resources  â”‚
â”‚ 5. Transformers      â”‚ Global transformations (labels, etc.)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Inclusion Priority:
Base < Components < Overlay < Patches < Transformers
  â†‘        â†‘          â†‘         â†‘           â†‘
Foundation Optional  Environment Modifications Global
Resources  Features  Specific   to Existing  Changes
```

### Component Integration Example
```yaml
# overlays/production/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

# 1. Base application resources
resources:
  - ../../base              # Core application

# 2. Components (processed in order)
components:
  - ../../components/monitoring        # Observability
  - ../../components/security-policies # Security layer
  - ../../components/ingress-nginx    # Traffic management
  - ../../components/postgresql-stack  # Database

# 3. Overlay-specific resources
  - production-secrets.yaml
  - production-ingress.yaml
  - hpa.yaml

# 4. Environment customization
commonLabels:
  environment: production
  tier: production

# 5. Component configuration overrides
configMapGenerator:
  - name: prometheus-config
    behavior: merge
    literals:
      - retention=90d         # Override component default

# 6. Component-specific patches
patches:
  - target:
      kind: Deployment
      labelSelector: component=monitoring-stack
    patch: production-monitoring-patch.yaml
```

## ğŸ”§ Component Configuration Patterns

### Pattern 1: Basic Component Inclusion
```yaml
# Simple component usage
# overlays/development/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - ../../base

components:
  - ../../components/monitoring

# Override component defaults for development
configMapGenerator:
  - name: prometheus-config
    behavior: merge
    literals:
      - retention=7d
      - log-level=debug
```

### Pattern 2: Conditional Component Inclusion
```yaml
# Environment-specific component inclusion
# overlays/production/kustomization.yaml

# Full production stack
components:
  - ../../components/monitoring
  - ../../components/security-policies
  - ../../components/postgresql-stack
  - ../../components/ingress-nginx
  - ../../components/backup-system
  - ../../components/alerting

---
# overlays/staging/kustomization.yaml

# Staging subset (cost-optimized)
components:
  - ../../components/monitoring
  - ../../components/security-policies
  - ../../components/postgresql-stack  # Internal DB for testing

---
# overlays/development/kustomization.yaml

# Minimal development setup
components:
  - ../../components/monitoring       # Basic observability
  # Uses external managed database
  # Minimal security for development
```

### Pattern 3: Component Composition Strategy
```yaml
# Complex multi-component integration
# overlays/enterprise/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - ../../base

# Strategic component ordering
components:
  # Foundation layer
  - ../../components/platform/base-policies
  - ../../components/platform/resource-quotas
  
  # Infrastructure layer
  - ../../components/infrastructure/ingress-nginx
  - ../../components/infrastructure/cert-manager
  - ../../components/infrastructure/dns-management
  
  # Security layer
  - ../../components/security/pod-security-policies
  - ../../components/security/network-policies
  - ../../components/security/rbac-policies
  
  # Data layer
  - ../../components/databases/postgresql-ha
  - ../../components/databases/redis-cluster
  - ../../components/databases/backup-system
  
  # Observability layer
  - ../../components/monitoring/prometheus-stack
  - ../../components/monitoring/logging-stack
  - ../../components/monitoring/tracing-system
  
  # Application services (optional components)
  - ../../components/services/message-queue
  - ../../components/services/search-engine

# Enterprise-specific configuration
commonLabels:
  tier: enterprise
  compliance: required
  backup: enabled

# Component configuration matrix
configMapGenerator:
  - name: prometheus-config
    behavior: merge
    literals:
      - retention=180d
      - ha-mode=true
      - alerting-enabled=true
      
  - name: postgresql-config  
    behavior: merge
    literals:
      - max-connections=500
      - shared-preload-libraries=pg_stat_statements
      - log-statement=all
```

## ğŸ›ï¸ Component Customization Techniques

### Configuration Override Strategies
```yaml
# Method 1: ConfigMap Merge
configMapGenerator:
  - name: component-config
    behavior: merge  # Merge with component's default ConfigMap
    literals:
      - custom-option=value

# Method 2: Environment Variables
patches:
  - target:
      kind: Deployment
      labelSelector: component=monitoring-stack
    patch: |-
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: not-used
      spec:
        template:
          spec:
            containers:
            - name: prometheus
              env:
              - name: CUSTOM_CONFIG
                value: "production-value"

# Method 3: Volume Mounts Override
patches:
  - target:
      kind: Deployment
      name: prometheus
    patch: |-
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: prometheus
      spec:
        template:
          spec:
            volumes:
            - name: custom-config
              configMap:
                name: custom-prometheus-config
            containers:
            - name: prometheus
              volumeMounts:
              - name: custom-config
                mountPath: /etc/prometheus/custom.yml
                subPath: custom.yml
```

### Advanced Component Configuration
```yaml
# Environment-specific component variants
# overlays/production/kustomization.yaml

components:
  - ../../components/monitoring

# Production-specific monitoring enhancements
patches:
  # Scale monitoring components
  - target:
      kind: Deployment
      name: prometheus
    patch: |-
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: prometheus
      spec:
        replicas: 2  # HA mode
        template:
          spec:
            containers:
            - name: prometheus
              resources:
                requests:
                  cpu: 2000m
                  memory: 8Gi
                limits:
                  cpu: 4000m
                  memory: 16Gi
              
  # Add production-specific volumes
  - target:
      kind: Deployment
      name: prometheus
    patch: |-
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: prometheus
      spec:
        template:
          spec:
            volumes:
            - name: prometheus-storage
              persistentVolumeClaim:
                claimName: prometheus-storage-pvc  # Replace emptyDir
                
# Production PVC for persistent storage
resources:
  - production-pvc.yaml

---
# production-pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: prometheus-storage-pvc
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 100Gi
  storageClassName: fast-ssd
```

## ğŸ”— Component Dependency Management

### Dependency Resolution Example
```yaml
# Complex dependency chain
components/application-stack/kustomization.yaml:
apiVersion: kustomize.config.k8s.io/v1alpha1
kind: Component

# This component depends on others
components:
  - ../postgresql-stack    # Provides database
  - ../redis-cache        # Provides caching
  - ../monitoring         # Provides observability

# Configure dependencies
configMapGenerator:
  - name: app-config
    literals:
      - DATABASE_URL=postgresql://postgres:5432/appdb
      - REDIS_URL=redis://redis-service:6379
      - METRICS_ENABLED=true

# Ensure proper service discovery
patches:
  - target:
      kind: Deployment
      name: application
    patch: |-
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: application
      spec:
        template:
          spec:
            initContainers:
            - name: wait-for-database
              image: postgres:14
              command:
              - sh
              - -c
              - |
                until pg_isready -h postgresql-service -p 5432; do
                  echo "Waiting for database..."
                  sleep 2
                done
            - name: wait-for-redis
              image: redis:7-alpine
              command:
              - sh
              - -c
              - |
                until redis-cli -h redis-service ping; do
                  echo "Waiting for Redis..."
                  sleep 2
                done
```

### Handling Component Conflicts
```yaml
# Component conflict resolution
# overlays/production/kustomization.yaml

components:
  - ../../components/monitoring-prometheus  # Provides Prometheus
  - ../../components/monitoring-grafana     # Provides Grafana
  # Both components might define ServiceMonitor resources

# Resolve conflicts with patches
patches:
  # Remove duplicate ServiceMonitor from grafana component
  - target:
      kind: ServiceMonitor
      name: grafana-metrics
      labelSelector: component=monitoring-grafana
    patch: |-
      $patch: delete
      
  # Use the Prometheus component's ServiceMonitor instead
  - target:
      kind: ServiceMonitor
      name: application-metrics
      labelSelector: component=monitoring-prometheus
    patch: |-
      apiVersion: monitoring.coreos.com/v1
      kind: ServiceMonitor
      metadata:
        name: application-metrics
      spec:
        endpoints:
        - port: metrics
          path: /metrics
        - port: grafana-metrics  # Add grafana endpoint
          path: /api/metrics
```

## ğŸŒ Multi-Environment Component Strategies

### Environment Matrix Configuration
```yaml
# Component matrix for different environments
# Base component selection matrix

Development Environment:
â”œâ”€â”€ components/monitoring (basic)
â”œâ”€â”€ components/logging (minimal)
â””â”€â”€ External managed database

Staging Environment:
â”œâ”€â”€ components/monitoring (full)
â”œâ”€â”€ components/logging (full)
â”œâ”€â”€ components/postgresql (single instance)
â””â”€â”€ components/security-basic

Production Environment:
â”œâ”€â”€ components/monitoring (HA)
â”œâ”€â”€ components/logging (HA + retention)
â”œâ”€â”€ components/postgresql (HA cluster)
â”œâ”€â”€ components/security-full
â”œâ”€â”€ components/backup-system
â””â”€â”€ components/disaster-recovery
```

### Environment-Specific Component Implementation
```yaml
# overlays/development/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - ../../base

components:
  - ../../components/monitoring

# Development optimizations
configMapGenerator:
  - name: prometheus-config
    behavior: merge
    literals:
      - retention=3d
      - storage-size=1Gi
      - evaluation-interval=30s

# Resource constraints for development
patches:
  - target:
      kind: Deployment
      labelSelector: component=monitoring-stack
    patch: |-
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: not-used
      spec:
        template:
          spec:
            containers:
            - name: prometheus
              resources:
                requests:
                  cpu: 100m
                  memory: 256Mi
                limits:
                  cpu: 200m
                  memory: 512Mi

---
# overlays/production/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - ../../base

components:
  - ../../components/monitoring
  - ../../components/postgresql-stack
  - ../../components/security-policies

# Production configuration
configMapGenerator:
  - name: prometheus-config
    behavior: merge
    literals:
      - retention=90d
      - storage-size=100Gi
      - evaluation-interval=15s
      - ha-replicas=2

# Production-grade resource allocation
patches:
  - target:
      kind: Deployment
      labelSelector: component=monitoring-stack
    patch: |-
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: not-used
      spec:
        replicas: 2  # HA setup
        template:
          spec:
            affinity:
              podAntiAffinity:
                requiredDuringSchedulingIgnoredDuringExecution:
                - labelSelector:
                    matchLabels:
                      component: monitoring-stack
                  topologyKey: kubernetes.io/hostname
            containers:
            - name: prometheus
              resources:
                requests:
                  cpu: 1000m
                  memory: 4Gi
                limits:
                  cpu: 2000m
                  memory: 8Gi
```

## ğŸ”„ Component State Management

### Stateful Component Handling
```yaml
# Handling stateful components across environments
# overlays/production/kustomization.yaml

components:
  - ../../components/postgresql-stack

# Production storage configuration
patches:
  - target:
      kind: StatefulSet
      name: postgresql
    patch: |-
      apiVersion: apps/v1
      kind: StatefulSet
      metadata:
        name: postgresql
      spec:
        volumeClaimTemplates:
        - metadata:
            name: postgresql-data
          spec:
            accessModes: [ "ReadWriteOnce" ]
            storageClassName: fast-ssd
            resources:
              requests:
                storage: 100Gi
            
        # Backup configuration
        - metadata:
            name: postgresql-backup
          spec:
            accessModes: [ "ReadWriteOnce" ]
            storageClassName: standard
            resources:
              requests:
                storage: 500Gi

# Backup CronJob configuration
  - target:
      kind: CronJob
      name: postgresql-backup
    patch: |-
      apiVersion: batch/v1
      kind: CronJob
      metadata:
        name: postgresql-backup
      spec:
        schedule: "0 2 * * *"  # Daily at 2 AM
        jobTemplate:
          spec:
            template:
              spec:
                containers:
                - name: backup
                  env:
                  - name: BACKUP_RETENTION_DAYS
                    value: "30"
                  - name: BACKUP_LOCATION
                    value: "s3://production-backups/postgresql"
```

### Component State Synchronization
```yaml
# Synchronizing state between components
# components/application-stack/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1alpha1
kind: Component

components:
  - ../postgresql-stack
  - ../redis-cache
  - ../monitoring

# State synchronization configuration
configMapGenerator:
  - name: sync-config
    literals:
      - DATABASE_READY_CHECK=postgresql-service:5432
      - CACHE_READY_CHECK=redis-service:6379
      - METRICS_ENDPOINT=prometheus-service:9090

# Init container to ensure dependencies are ready
patches:
  - target:
      kind: Deployment
      name: application
    patch: |-
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: application
      spec:
        template:
          spec:
            initContainers:
            - name: wait-for-dependencies
              image: busybox:1.35
              command:
              - sh
              - -c
              - |
                echo "Waiting for dependencies..."
                until nc -z postgresql-service 5432; do sleep 1; done
                until nc -z redis-service 6379; do sleep 1; done
                echo "All dependencies ready!"
```

## ğŸš€ Advanced Integration Patterns

### Component Composition with Inheritance
```yaml
# Advanced component composition
# overlays/platform-complete/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - ../../base

# Hierarchical component inclusion
components:
  # Platform foundation
  - ../../components/platform-base
  
  # Infrastructure layer (depends on platform-base)
  - ../../components/infrastructure-complete
  
  # Application layer (depends on infrastructure)
  - ../../components/application-services

# Global platform configuration
commonLabels:
  platform: enterprise
  managed-by: platform-team

# Platform-wide settings
configMapGenerator:
  - name: platform-config
    literals:
      - LOG_LEVEL=info
      - METRICS_ENABLED=true
      - SECURITY_ENABLED=true
      - BACKUP_ENABLED=true
      - DISASTER_RECOVERY=true

# Platform-specific patches
patches:
  - path: platform-patches
    target:
      labelSelector: platform=enterprise
```

### Dynamic Component Configuration
```yaml
# Dynamic component configuration using replacements
# overlays/dynamic/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - ../../base

components:
  - ../../components/monitoring

# Dynamic configuration using replacements
replacements:
  # Propagate environment to all component configurations
  - source:
      kind: ConfigMap
      name: environment-config
      fieldPath: data.ENVIRONMENT_NAME
    targets:
      - select:
          kind: ConfigMap
          labelSelector: component=monitoring-stack
        fieldPaths:
          - data.environment
          
  # Dynamic resource sizing based on environment
  - source:
      kind: ConfigMap
      name: environment-config
      fieldPath: data.RESOURCE_TIER
    targets:
      - select:
          kind: Deployment
          labelSelector: component=monitoring-stack
        fieldPaths:
          - spec.template.spec.containers.[name=prometheus].resources.requests.memory
        options:
          delimiter: ""

configMapGenerator:
  - name: environment-config
    literals:
      - ENVIRONMENT_NAME=production
      - RESOURCE_TIER=4Gi
```

## ğŸ§ª Testing Component Integration

### Integration Testing Scripts
```bash
#!/bin/bash
# scripts/test-component-integration.sh

set -e

OVERLAY_PATH=${1:-overlays/production}
TEST_NAMESPACE="component-test-$(date +%s)"

echo "ğŸ§ª Testing component integration for: $OVERLAY_PATH"

# Create test namespace
kubectl create namespace "$TEST_NAMESPACE" || true

# Test 1: Validate component syntax
echo "1ï¸âƒ£ Validating component syntax..."
kubectl kustomize "$OVERLAY_PATH" --dry-run=client > /tmp/test-manifest.yaml || {
    echo "âŒ Component syntax validation failed"
    exit 1
}

# Test 2: Server-side validation
echo "2ï¸âƒ£ Server-side validation..."
kubectl apply --dry-run=server -f /tmp/test-manifest.yaml || {
    echo "âŒ Server-side validation failed"
    exit 1
}

# Test 3: Check component dependencies
echo "3ï¸âƒ£ Checking component dependencies..."
component_deps=$(grep -A 10 "components:" "$OVERLAY_PATH/kustomization.yaml" | grep "^  -" || true)
if [ -n "$component_deps" ]; then
    echo "Components found:"
    echo "$component_deps"
    
    # Validate each component individually
    while IFS= read -r comp; do
        comp_path=$(echo "$comp" | sed 's/^  - //')
        echo "  Validating: $comp_path"
        kubectl kustomize "$comp_path" --dry-run=client > /dev/null || {
            echo "âŒ Component validation failed: $comp_path"
            exit 1
        }
    done <<< "$component_deps"
fi

# Test 4: Resource count validation
echo "4ï¸âƒ£ Validating expected resources..."
deployments=$(grep -c "kind: Deployment" /tmp/test-manifest.yaml || echo "0")
services=$(grep -c "kind: Service" /tmp/test-manifest.yaml || echo "0")
configmaps=$(grep -c "kind: ConfigMap" /tmp/test-manifest.yaml || echo "0")

echo "  Deployments: $deployments"
echo "  Services: $services"
echo "  ConfigMaps: $configmaps"

# Test 5: Label consistency
echo "5ï¸âƒ£ Checking label consistency..."
kubectl kustomize "$OVERLAY_PATH" | yq e '.metadata.labels' - | sort -u > /tmp/labels.txt
echo "  Unique labels found: $(wc -l < /tmp/labels.txt)"

# Test 6: Component resource conflicts
echo "6ï¸âƒ£ Checking for resource conflicts..."
kubectl kustomize "$OVERLAY_PATH" | yq e '.metadata | .kind + "/" + .name' - | sort | uniq -d > /tmp/conflicts.txt
if [ -s /tmp/conflicts.txt ]; then
    echo "âŒ Resource conflicts found:"
    cat /tmp/conflicts.txt
    exit 1
fi

echo "âœ… All component integration tests passed!"

# Cleanup
rm -f /tmp/test-manifest.yaml /tmp/labels.txt /tmp/conflicts.txt
```

### Component Health Checks
```yaml
# Component health check configuration
# overlays/production/component-health-checks.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: health-check-config
data:
  health-checks.sh: |
    #!/bin/bash
    # Component health validation script
    
    check_component() {
        local component=$1
        local expected_pods=$2
        
        echo "Checking component: $component"
        
        # Check pod readiness
        ready_pods=$(kubectl get pods -l component="$component" -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}' | wc -w)
        
        if [ "$ready_pods" -ge "$expected_pods" ]; then
            echo "âœ… $component: $ready_pods/$expected_pods pods ready"
        else
            echo "âŒ $component: $ready_pods/$expected_pods pods ready"
            return 1
        fi
    }
    
    # Check all components
    check_component "monitoring-stack" 2
    check_component "postgresql-stack" 1
    check_component "security-policies" 0  # No pods expected
    
    echo "ğŸ‰ All components healthy!"

---
# Health check CronJob
apiVersion: batch/v1
kind: CronJob
metadata:
  name: component-health-check
spec:
  schedule: "*/15 * * * *"  # Every 15 minutes
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: health-checker
          containers:
          - name: health-check
            image: bitnami/kubectl:latest
            command:
            - sh
            - /scripts/health-checks.sh
            volumeMounts:
            - name: health-scripts
              mountPath: /scripts
          volumes:
          - name: health-scripts
            configMap:
              name: health-check-config
              defaultMode: 0755
          restartPolicy: OnFailure
```

## ğŸ“Š Monitoring Component Integration

### Component Metrics Collection
```yaml
# Component metrics configuration
# overlays/production/component-monitoring.yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: component-metrics
spec:
  selector:
    matchLabels:
      component-metrics: enabled
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics
    
---
# Component health dashboard ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: component-dashboard
data:
  component-health.json: |
    {
      "dashboard": {
        "title": "Component Health Dashboard",
        "panels": [
          {
            "title": "Component Status",
            "type": "stat",
            "targets": [
              {
                "expr": "kube_deployment_status_replicas_available{deployment=~\".*-component-.*\"}"
              }
            ]
          },
          {
            "title": "Component Resource Usage",
            "type": "graph",
            "targets": [
              {
                "expr": "rate(container_cpu_usage_seconds_total{pod=~\".*-component-.*\"}[5m])"
              }
            ]
          }
        ]
      }
    }
```

## ğŸ¯ Best Practices Summary

### âœ… Component Integration Best Practices

1. **Component Order Matters**
```yaml
components:
  - ../platform-base      # 1. Foundation first
  - ../security-policies  # 2. Security layer
  - ../infrastructure     # 3. Infrastructure
  - ../applications       # 4. Applications last
```

2. **Configuration Override Strategy**
```yaml
# Good: Merge behavior for additive changes
configMapGenerator:
  - name: component-config
    behavior: merge  # Add to component defaults

# Good: Replace for complete override
configMapGenerator:
  - name: component-config
    behavior: replace  # Replace component defaults
```

3. **Component Conflict Resolution**
```yaml
# Good: Explicit conflict handling
patches:
  - target:
      kind: Resource
      name: conflicting-resource
    patch: |-
      $patch: delete  # Remove conflicting resource
```

4. **Environment-Specific Component Configuration**
```yaml
# Good: Clear environment separation
# production/kustomization.yaml
components:
  - ../../components/monitoring-ha    # Production version
  
# development/kustomization.yaml  
components:
  - ../../components/monitoring-basic # Development version
```

### âš ï¸ Common Pitfalls and Solutions

1. **Component Dependency Issues**
```yaml
# Problem: Wrong component order
components:
  - ../application     # Depends on database
  - ../postgresql     # Should be first

# Solution: Correct dependency order
components:
  - ../postgresql     # Foundation first
  - ../application    # Dependent components after
```

2. **Resource Name Conflicts**
```yaml
# Problem: Multiple components create same resource
# Solution: Use namespaced names or patches to resolve

patches:
  - target:
      kind: ConfigMap
      name: config
      labelSelector: component=comp1
    patch: |-
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: comp1-config  # Rename to avoid conflict
```

## ğŸ“ Summary

### Key Concepts Mastered
1. **Component Integration**: Including and configuring components in overlays
2. **Dependency Management**: Handling component dependencies and conflicts
3. **Configuration Override**: Customizing component behavior per environment
4. **Testing and Validation**: Ensuring component integration works correctly

### Advanced Techniques Learned
- Multi-component composition strategies
- Dynamic component configuration
- Stateful component handling
- Component health monitoring
- Environment-specific component variants

Component integration in overlays represents the most powerful aspect of Kustomize, enabling you to build complex, maintainable, and reusable infrastructure configurations that scale across your entire organization.

## â¡ï¸ Next Steps
You've now mastered component integration! Proceed to [10. Practice-Extract-Common-Configurations-into-Components.md](10.%20Practice-Extract-Common-Configurations-into-Components.md) to practice identifying and extracting common configuration patterns from existing projects into reusable components.