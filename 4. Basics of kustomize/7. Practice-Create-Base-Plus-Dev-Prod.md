# 7. Practice: Create Base + Dev/Prod

## üéØ Learning Objectives
- [ ] Build a complete base + overlay project from scratch
- [ ] Implement development and production environments with proper differentiation
- [ ] Apply naming, labeling, and patching strategies in a real scenario
- [ ] Practice validation and deployment workflows
- [ ] Troubleshoot common configuration issues

## üìã Project Overview

### Scenario: E-commerce Web Application
```
Application Stack:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 E-commerce Platform                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Frontend:    React.js web application (webapp)             ‚îÇ
‚îÇ Backend:     Node.js API server (api)                      ‚îÇ
‚îÇ Database:    PostgreSQL (managed external service)         ‚îÇ
‚îÇ Cache:       Redis (in-cluster)                            ‚îÇ
‚îÇ Ingress:     NGINX Ingress Controller                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Environments:
Development:  Single replicas, debug enabled, resource-light
Production:   Multiple replicas, hardened security, HA setup
```

### Final Project Structure
```
ecommerce-platform/
‚îú‚îÄ‚îÄ base/
‚îÇ   ‚îú‚îÄ‚îÄ kustomization.yaml
‚îÇ   ‚îú‚îÄ‚îÄ webapp-deployment.yaml
‚îÇ   ‚îú‚îÄ‚îÄ webapp-service.yaml
‚îÇ   ‚îú‚îÄ‚îÄ api-deployment.yaml
‚îÇ   ‚îú‚îÄ‚îÄ api-service.yaml
‚îÇ   ‚îú‚îÄ‚îÄ redis-deployment.yaml
‚îÇ   ‚îú‚îÄ‚îÄ redis-service.yaml
‚îÇ   ‚îî‚îÄ‚îÄ configmap.yaml
‚îú‚îÄ‚îÄ overlays/
‚îÇ   ‚îú‚îÄ‚îÄ development/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ kustomization.yaml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dev-patches.yaml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dev-ingress.yaml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dev-secrets.yaml
‚îÇ   ‚îî‚îÄ‚îÄ production/
‚îÇ       ‚îú‚îÄ‚îÄ kustomization.yaml
‚îÇ       ‚îú‚îÄ‚îÄ prod-patches/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ webapp-resources.yaml
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ api-resources.yaml
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ security.yaml
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ monitoring.yaml
‚îÇ       ‚îú‚îÄ‚îÄ prod-ingress.yaml
‚îÇ       ‚îú‚îÄ‚îÄ prod-secrets.yaml
‚îÇ       ‚îú‚îÄ‚îÄ hpa.yaml
‚îÇ       ‚îî‚îÄ‚îÄ network-policy.yaml
‚îî‚îÄ‚îÄ validation/
    ‚îú‚îÄ‚îÄ validate.sh
    ‚îî‚îÄ‚îÄ deploy.sh
```

## üèóÔ∏è Step 1: Create Base Configuration

### Initialize Project Structure
```bash
# Create project directory structure
mkdir -p ecommerce-platform/{base,overlays/{development,production},validation}
cd ecommerce-platform
```

### Base kustomization.yaml
```yaml
# base/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

metadata:
  name: ecommerce-base
  annotations:
    config.kubernetes.io/local-config: "true"

resources:
  - webapp-deployment.yaml
  - webapp-service.yaml
  - api-deployment.yaml
  - api-service.yaml
  - redis-deployment.yaml
  - redis-service.yaml
  - configmap.yaml

# Base labels applied to all resources
commonLabels:
  app.kubernetes.io/part-of: ecommerce-platform
  app.kubernetes.io/managed-by: kustomize
  team: platform
  project: ecommerce

# Base images (will be overridden in environments)
images:
  - name: webapp
    newTag: latest
  - name: api
    newTag: latest
  - name: redis
    newTag: 7-alpine

# Base ConfigMap generation
configMapGenerator:
  - name: app-config
    literals:
      - NODE_ENV=production
      - LOG_LEVEL=info
      - REDIS_URL=redis://redis-service:6379
      - API_URL=http://api-service:3000
    files:
      - app.conf
```

### Frontend Deployment (webapp)
```yaml
# base/webapp-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
  labels:
    app.kubernetes.io/name: webapp
    app.kubernetes.io/component: frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: webapp
      app.kubernetes.io/component: frontend
  template:
    metadata:
      labels:
        app.kubernetes.io/name: webapp
        app.kubernetes.io/component: frontend
    spec:
      containers:
      - name: webapp
        image: webapp:latest
        ports:
        - containerPort: 80
          name: http
        env:
        - name: API_BASE_URL
          value: "/api"
        - name: NODE_ENV
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: NODE_ENV
        envFrom:
        - configMapRef:
            name: app-config
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        livenessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /ready
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 10
        securityContext:
          allowPrivilegeEscalation: false
          runAsNonRoot: true
          runAsUser: 1000
```

### Backend API Deployment
```yaml
# base/api-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
  labels:
    app.kubernetes.io/name: api
    app.kubernetes.io/component: backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: api
      app.kubernetes.io/component: backend
  template:
    metadata:
      labels:
        app.kubernetes.io/name: api
        app.kubernetes.io/component: backend
    spec:
      containers:
      - name: api
        image: api:latest
        ports:
        - containerPort: 3000
          name: http
        - containerPort: 9090
          name: metrics
        env:
        - name: PORT
          value: "3000"
        - name: REDIS_URL
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: REDIS_URL
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-url
        envFrom:
        - configMapRef:
            name: app-config
        resources:
          requests:
            cpu: 200m
            memory: 256Mi
          limits:
            cpu: 1000m
            memory: 1Gi
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 45
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 10
        securityContext:
          allowPrivilegeEscalation: false
          runAsNonRoot: true
          runAsUser: 1000
```

### Redis Cache Deployment
```yaml
# base/redis-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  labels:
    app.kubernetes.io/name: redis
    app.kubernetes.io/component: cache
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: redis
      app.kubernetes.io/component: cache
  template:
    metadata:
      labels:
        app.kubernetes.io/name: redis
        app.kubernetes.io/component: cache
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        ports:
        - containerPort: 6379
          name: redis
        args:
        - redis-server
        - --appendonly
        - "yes"
        - --maxmemory
        - 256mb
        - --maxmemory-policy
        - allkeys-lru
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 200m
            memory: 256Mi
        volumeMounts:
        - name: redis-data
          mountPath: /data
        livenessProbe:
          exec:
            command:
            - redis-cli
            - ping
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - redis-cli
            - ping
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: redis-data
        emptyDir: {}
```

### Service Definitions
```yaml
# base/webapp-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: webapp-service
  labels:
    app.kubernetes.io/name: webapp
    app.kubernetes.io/component: frontend
spec:
  type: ClusterIP
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
    name: http
  selector:
    app.kubernetes.io/name: webapp
    app.kubernetes.io/component: frontend

---
# base/api-service.yaml  
apiVersion: v1
kind: Service
metadata:
  name: api-service
  labels:
    app.kubernetes.io/name: api
    app.kubernetes.io/component: backend
spec:
  type: ClusterIP
  ports:
  - port: 3000
    targetPort: 3000
    protocol: TCP
    name: http
  - port: 9090
    targetPort: 9090
    protocol: TCP
    name: metrics
  selector:
    app.kubernetes.io/name: api
    app.kubernetes.io/component: backend

---
# base/redis-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: redis-service
  labels:
    app.kubernetes.io/name: redis
    app.kubernetes.io/component: cache
spec:
  type: ClusterIP
  ports:
  - port: 6379
    targetPort: 6379
    protocol: TCP
    name: redis
  selector:
    app.kubernetes.io/name: redis
    app.kubernetes.io/component: cache
```

### Base ConfigMap
```yaml
# base/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: base-config
  labels:
    app.kubernetes.io/name: config
    app.kubernetes.io/component: configuration
data:
  app.conf: |
    # Base application configuration
    server {
        listen 80;
        server_name _;
        
        # Frontend static files
        location / {
            root /usr/share/nginx/html;
            index index.html index.htm;
            try_files $uri $uri/ /index.html;
        }
        
        # API proxy
        location /api {
            proxy_pass http://api-service:3000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
        
        # Health check
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }
```

## üõ†Ô∏è Step 2: Development Environment Overlay

### Development kustomization.yaml
```yaml
# overlays/development/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

metadata:
  name: ecommerce-development
  annotations:
    environment: development

resources:
  - ../../base
  - dev-ingress.yaml
  - dev-secrets.yaml

# Development naming
namePrefix: dev-
nameSuffix: -v1

# Development-specific labels
commonLabels:
  environment: development
  tier: non-production
  debug-mode: enabled

commonAnnotations:
  environment: development
  auto-cleanup: "true"
  cost-center: development
  contact.team: platform-dev@company.com

# Development images
images:
  - name: webapp
    newTag: dev-latest
  - name: api
    newTag: dev-latest
  - name: redis
    newTag: 7-alpine

# Development configuration overrides
configMapGenerator:
  - name: app-config
    behavior: merge
    literals:
      - NODE_ENV=development
      - LOG_LEVEL=debug
      - DEBUG_MODE=true
      - CORS_ENABLED=true
      - HOT_RELOAD=true
      - METRICS_ENABLED=false

# Development resource scaling
replicas:
  - name: webapp
    count: 1
  - name: api
    count: 1
  - name: redis
    count: 1

# Development patches
patches:
  - path: dev-patches.yaml
    target:
      kind: Deployment
```

### Development Patches
```yaml
# overlays/development/dev-patches.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  template:
    spec:
      containers:
      - name: webapp
        env:
        - name: REACT_APP_ENV
          value: development
        - name: REACT_APP_API_URL
          value: http://dev-api.local/api
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 200m
            memory: 256Mi
        # Development volume for hot reload
        volumeMounts:
        - name: dev-source
          mountPath: /app/src
      volumes:
      - name: dev-source
        hostPath:
          path: /host/dev/webapp/src
          type: DirectoryOrCreate

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
spec:
  template:
    spec:
      containers:
      - name: api
        env:
        - name: NODE_ENV
          value: development
        - name: DEBUG
          value: "ecommerce:*"
        - name: HOT_RELOAD
          value: "true"
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
        # Development debugging ports
        ports:
        - containerPort: 3000
          name: http
        - containerPort: 9229
          name: debug

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
spec:
  template:
    spec:
      containers:
      - name: redis
        resources:
          requests:
            cpu: 25m
            memory: 32Mi
          limits:
            cpu: 100m
            memory: 128Mi
```

### Development Ingress
```yaml
# overlays/development/dev-ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: dev-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/cors-allow-origin: "*"
    nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, PUT, DELETE, OPTIONS"
    nginx.ingress.kubernetes.io/cors-allow-headers: "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization"
    nginx.ingress.kubernetes.io/enable-cors: "true"
    cert-manager.io/cluster-issuer: letsencrypt-staging
spec:
  tls:
  - hosts:
    - dev-ecommerce.local
    - dev-api.local
    secretName: dev-ecommerce-tls
  rules:
  - host: dev-ecommerce.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: webapp-service
            port:
              number: 80
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 3000
  - host: dev-api.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 3000
```

### Development Secrets
```yaml
# overlays/development/dev-secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
type: Opaque
stringData:
  database-url: "postgresql://dev_user:dev_password@dev-postgres:5432/ecommerce_dev"
  jwt-secret: "dev-jwt-secret-key-not-for-production"
  redis-password: ""  # No password in development
  external-api-key: "dev-external-api-key"
  webhook-secret: "dev-webhook-secret"
```

## üè≠ Step 3: Production Environment Overlay

### Production kustomization.yaml
```yaml
# overlays/production/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

metadata:
  name: ecommerce-production
  annotations:
    environment: production
    backup-policy: daily

resources:
  - ../../base
  - prod-ingress.yaml
  - prod-secrets.yaml
  - hpa.yaml
  - network-policy.yaml

# Production naming (clean names)
commonLabels:
  environment: production
  tier: production
  criticality: high
  monitoring: enabled
  backup: enabled

commonAnnotations:
  environment: production
  backup-schedule: "0 2 * * *"
  monitoring-tier: critical
  sla-tier: gold
  contact.team: platform-ops@company.com

# Production images (specific versions)
images:
  - name: webapp
    newTag: v1.2.3
  - name: api
    newTag: v1.2.3
  - name: redis
    newTag: 7.0.8

# Production configuration
configMapGenerator:
  - name: app-config
    behavior: replace
    literals:
      - NODE_ENV=production
      - LOG_LEVEL=warn
      - DEBUG_MODE=false
      - CORS_ENABLED=false
      - METRICS_ENABLED=true
      - HEALTH_CHECKS_ENABLED=true
      - PERFORMANCE_MONITORING=true
      - REDIS_PASSWORD_REQUIRED=true

# Production scaling
replicas:
  - name: webapp
    count: 3
  - name: api
    count: 5
  - name: redis
    count: 1  # Redis will use HA setup externally

# Production patches
patches:
  - path: prod-patches/webapp-resources.yaml
    target:
      kind: Deployment
      name: webapp
  - path: prod-patches/api-resources.yaml
    target:
      kind: Deployment
      name: api
  - path: prod-patches/security.yaml
    target:
      kind: Deployment
  - path: prod-patches/monitoring.yaml
    target:
      kind: Deployment
```

### Production Resource Patches
```yaml
# overlays/production/prod-patches/webapp-resources.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 2
      maxUnavailable: 1
  template:
    metadata:
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9090"
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app.kubernetes.io/name
                  operator: In
                  values:
                  - webapp
              topologyKey: kubernetes.io/hostname
      containers:
      - name: webapp
        env:
        - name: NODE_ENV
          value: production
        - name: REACT_APP_ENV
          value: production
        resources:
          requests:
            cpu: 500m
            memory: 512Mi
          limits:
            cpu: 1000m
            memory: 1Gi
        livenessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 60
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: 80
          initialDelaySeconds: 15
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 2
        startupProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 30

---
# overlays/production/prod-patches/api-resources.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 2
      maxUnavailable: 1
  template:
    metadata:
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9090"
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app.kubernetes.io/name
                  operator: In
                  values:
                  - api
              topologyKey: kubernetes.io/hostname
      containers:
      - name: api
        env:
        - name: NODE_ENV
          value: production
        - name: NODE_OPTIONS
          value: "--max-old-space-size=2048"
        resources:
          requests:
            cpu: 1000m
            memory: 1Gi
          limits:
            cpu: 2000m
            memory: 2Gi
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 60
          periodSeconds: 30
          timeoutSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 20
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 2
```

### Production Security Patch
```yaml
# overlays/production/prod-patches/security.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  template:
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 2000
      containers:
      - name: webapp
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
        volumeMounts:
        - name: tmp-volume
          mountPath: /tmp
        - name: var-cache
          mountPath: /var/cache/nginx
        - name: var-run
          mountPath: /var/run
      volumes:
      - name: tmp-volume
        emptyDir: {}
      - name: var-cache
        emptyDir: {}
      - name: var-run
        emptyDir: {}

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
spec:
  template:
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 2000
      containers:
      - name: api
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
        volumeMounts:
        - name: tmp-volume
          mountPath: /tmp
        - name: logs-volume
          mountPath: /app/logs
      volumes:
      - name: tmp-volume
        emptyDir: {}
      - name: logs-volume
        emptyDir: {}
```

### Production HPA
```yaml
# overlays/production/hpa.yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: webapp-hpa
  labels:
    app.kubernetes.io/name: webapp
    app.kubernetes.io/component: frontend
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: webapp
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80

---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: api-hpa
  labels:
    app.kubernetes.io/name: api
    app.kubernetes.io/component: backend
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: api
  minReplicas: 3
  maxReplicas: 20
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
```

## üß™ Step 4: Validation and Testing

### Validation Script
```bash
#!/bin/bash
# validation/validate.sh

set -e

echo "üîç Validating Kustomize Configurations..."

# Function to validate environment
validate_environment() {
    local env=$1
    echo "Validating $env environment..."
    
    # Syntax validation
    kubectl kustomize "overlays/$env" --dry-run=client > /dev/null || {
        echo "‚ùå $env: Syntax validation failed"
        return 1
    }
    
    # Server-side validation (if cluster available)
    if kubectl cluster-info > /dev/null 2>&1; then
        kubectl kustomize "overlays/$env" --dry-run=server > /dev/null || {
            echo "‚ùå $env: Server validation failed"
            return 1
        }
    fi
    
    # Generate manifests for inspection
    kubectl kustomize "overlays/$env" > "validation/${env}-manifest.yaml"
    
    # Validate resource counts
    local deployments=$(kubectl kustomize "overlays/$env" | grep -c "kind: Deployment" || true)
    local services=$(kubectl kustomize "overlays/$env" | grep -c "kind: Service" || true)
    
    echo "‚úÖ $env: $deployments deployments, $services services"
    
    # Check resource allocation
    echo "Resource allocation for $env:"
    kubectl kustomize "overlays/$env" | yq e 'select(.kind == "Deployment") | .metadata.name + ": " + (.spec.replicas | tostring)' -
    
    return 0
}

# Validate base configuration
echo "Validating base configuration..."
kubectl kustomize base --dry-run=client > /dev/null || {
    echo "‚ùå Base configuration validation failed"
    exit 1
}
echo "‚úÖ Base configuration valid"

# Validate environments
validate_environment "development"
validate_environment "production"

# Compare configurations
echo "üìä Configuration comparison:"
echo "Development vs Production differences:"
diff -u "validation/development-manifest.yaml" "validation/production-manifest.yaml" | head -20 || true

echo "‚úÖ All validations completed successfully!"
```

### Deployment Script
```bash
#!/bin/bash
# validation/deploy.sh

set -e

ENVIRONMENT=${1:-development}
DRY_RUN=${2:-false}

echo "üöÄ Deploying to $ENVIRONMENT environment..."

# Validate configuration first
echo "Validating configuration..."
kubectl kustomize "overlays/$ENVIRONMENT" --dry-run=server || {
    echo "‚ùå Configuration validation failed"
    exit 1
}

# Deploy or dry-run
if [[ "$DRY_RUN" == "true" ]]; then
    echo "üîç Dry run deployment:"
    kubectl apply -k "overlays/$ENVIRONMENT" --dry-run=client
else
    echo "üì¶ Applying configuration..."
    kubectl apply -k "overlays/$ENVIRONMENT" --wait
    
    # Wait for rollout
    echo "‚è≥ Waiting for rollout to complete..."
    kubectl rollout status deployment -l environment=$ENVIRONMENT --timeout=300s
    
    # Show status
    echo "üìä Deployment status:"
    kubectl get pods,svc,ingress -l environment=$ENVIRONMENT
fi

echo "‚úÖ Deployment completed!"
```

### Make Scripts Executable
```bash
chmod +x validation/validate.sh
chmod +x validation/deploy.sh
```

## üß™ Step 5: Testing and Verification

### Test Base Configuration
```bash
# Validate base configuration
kubectl kustomize base --dry-run=client

# Check base resources
kubectl kustomize base | grep -E "^(kind|name):"
```

### Test Development Environment
```bash
# Validate development overlay
kubectl kustomize overlays/development --dry-run=client

# Check development naming
kubectl kustomize overlays/development | grep "name:" | head -10

# Check development resource allocation
kubectl kustomize overlays/development | yq e 'select(.kind == "Deployment") | .spec.template.spec.containers[0].resources' -

# Check development replicas
kubectl kustomize overlays/development | yq e 'select(.kind == "Deployment") | .spec.replicas' -
```

### Test Production Environment
```bash
# Validate production overlay
kubectl kustomize overlays/production --dry-run=client

# Compare resource allocation
echo "Development resources:"
kubectl kustomize overlays/development | yq e 'select(.kind == "Deployment" and .metadata.name == "dev-webapp-v1") | .spec.template.spec.containers[0].resources' -

echo "Production resources:"
kubectl kustomize overlays/production | yq e 'select(.kind == "Deployment" and .metadata.name == "webapp") | .spec.template.spec.containers[0].resources' -
```

### Run Comprehensive Validation
```bash
# Run the validation script
./validation/validate.sh

# Deploy to development (dry run)
./validation/deploy.sh development true

# Deploy to development (if cluster available)
# ./validation/deploy.sh development false
```

## üìä Verification Checklist

### Configuration Verification
```bash
# ‚úÖ Verify naming conventions
kubectl kustomize overlays/development | grep "name:" | grep "dev-"
kubectl kustomize overlays/production | grep "name:" | grep -v "dev-"

# ‚úÖ Verify labels
kubectl kustomize overlays/development | yq e '.metadata.labels.environment' - | sort -u
kubectl kustomize overlays/production | yq e '.metadata.labels.environment' - | sort -u

# ‚úÖ Verify resource scaling
kubectl kustomize overlays/development | yq e 'select(.kind == "Deployment") | .spec.replicas' -
kubectl kustomize overlays/production | yq e 'select(.kind == "Deployment") | .spec.replicas' -

# ‚úÖ Verify image tags
kubectl kustomize overlays/development | yq e 'select(.kind == "Deployment") | .spec.template.spec.containers[0].image' -
kubectl kustomize overlays/production | yq e 'select(.kind == "Deployment") | .spec.template.spec.containers[0].image' -
```

### Security Verification
```bash
# ‚úÖ Verify security contexts are applied
kubectl kustomize overlays/production | yq e 'select(.kind == "Deployment") | .spec.template.spec.securityContext' -

# ‚úÖ Verify resource limits are set
kubectl kustomize overlays/production | yq e 'select(.kind == "Deployment") | .spec.template.spec.containers[0].resources.limits' -

# ‚úÖ Verify non-root execution
kubectl kustomize overlays/production | yq e 'select(.kind == "Deployment") | .spec.template.spec.containers[0].securityContext.runAsNonRoot' -
```

## üéØ Success Criteria

### ‚úÖ Project Completion Checklist
- [ ] Base configuration with 3 services (webapp, api, redis)
- [ ] Development overlay with debug configurations and single replicas
- [ ] Production overlay with hardened security and multiple replicas
- [ ] Proper naming conventions (dev- prefix for development)
- [ ] Appropriate resource allocation per environment
- [ ] Working ingress configurations for both environments
- [ ] Validation scripts that pass successfully
- [ ] Security contexts applied in production
- [ ] HPA configured for production scaling

### ‚úÖ Verification Commands
```bash
# All these should pass:
kubectl kustomize base --dry-run=client
kubectl kustomize overlays/development --dry-run=client
kubectl kustomize overlays/production --dry-run=client
./validation/validate.sh
```

## üèÜ Challenge Extensions

### Advanced Practice Ideas
1. **Multi-Region Deployment**: Add `us-east` and `eu-west` overlays
2. **Canary Deployment**: Create canary overlay with traffic splitting
3. **Monitoring Stack**: Add Prometheus and Grafana to production
4. **Database Migration**: Add database initialization jobs
5. **Backup Strategy**: Add CronJobs for automated backups

### Next Level Configuration
```yaml
# Challenge: Add monitoring to production
# overlays/production/monitoring.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus
# ... prometheus configuration

# Challenge: Add network policies
# overlays/production/network-policies.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
# ... network security rules
```

## üéì Key Takeaways

### What You've Learned
1. **Complete Kustomize Workflow**: From base to production-ready overlays
2. **Environment Differentiation**: Proper separation of concerns between dev/prod
3. **Resource Management**: Scaling configurations appropriately per environment
4. **Security Hardening**: Progressive security from development to production
5. **Validation Practices**: Systematic testing and verification of configurations

### Best Practices Applied
- Consistent naming and labeling strategies
- Progressive complexity (simple dev ‚Üí complex prod)
- Security by default in production
- Resource efficiency in development
- Comprehensive validation workflows

Congratulations! You've successfully created a complete multi-environment Kustomize configuration. This foundation can now be extended with additional services, environments, and advanced features.

## ‚û°Ô∏è Next Steps
Now that you've mastered creating complete base + overlay configurations, proceed to [8. Reusable-Kustomize-Components.md](8.%20Reusable-Kustomize-Components.md) to learn how to create reusable components that can be shared across multiple projects and environments.