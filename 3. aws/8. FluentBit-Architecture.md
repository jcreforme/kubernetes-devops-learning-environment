# 8. FluentBit Architecture & Log Forwarding

## ğŸ¯ Learning Objectives
- [ ] Understand FluentBit's role in log management architecture
- [ ] Learn how FluentBit forwards logs to CloudWatch
- [ ] Master configuration files and deployment patterns
- [ ] Configure parsing, filtering, and routing rules
- [ ] Troubleshoot log forwarding issues
- [ ] Optimize FluentBit performance and resource usage

## ğŸ“‹ FluentBit Overview

### What is FluentBit?
```
FluentBit is a lightweight, high-performance log processor and forwarder:
âœ… Fast & Lightweight (C/C++ written)
âœ… Low memory footprint (~650KB)
âœ… High throughput (millions of events/second)
âœ… Cloud-native compatible
âœ… Kubernetes-native integration
âœ… Multiple input/output plugins
âœ… Real-time log processing
```

### FluentBit vs. Fluent/Fluentd
```
Comparison Matrix:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Feature             â”‚ FluentBit   â”‚ Fluentd         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Language            â”‚ C/C++       â”‚ Ruby            â”‚
â”‚ Memory Usage        â”‚ ~650KB      â”‚ ~40MB           â”‚
â”‚ Performance         â”‚ Very High   â”‚ High            â”‚
â”‚ Plugins             â”‚ Built-in    â”‚ Gem-based       â”‚
â”‚ Configuration       â”‚ Simple      â”‚ Complex         â”‚
â”‚ Use Case           â”‚ Edge/K8s     â”‚ Aggregation     â”‚
â”‚ Resource Usage      â”‚ Minimal     â”‚ Moderate        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Architecture Components
```
FluentBit Architecture:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FluentBit Engine                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Input Plugins    â”‚ Filter Plugins  â”‚ Output Plugins   â”‚
â”‚ â”œâ”€â”€â”€ tail        â”‚ â”œâ”€â”€â”€ parser     â”‚ â”œâ”€â”€â”€ cloudwatch  â”‚
â”‚ â”œâ”€â”€â”€ systemd     â”‚ â”œâ”€â”€â”€ grep       â”‚ â”œâ”€â”€â”€ s3          â”‚
â”‚ â”œâ”€â”€â”€ docker      â”‚ â”œâ”€â”€â”€ record     â”‚ â”œâ”€â”€â”€ kinesis     â”‚
â”‚ â”œâ”€â”€â”€ kubernetes  â”‚ â”œâ”€â”€â”€ modify     â”‚ â”œâ”€â”€â”€ elasticsearchâ”‚
â”‚ â”œâ”€â”€â”€ tcp         â”‚ â””â”€â”€â”€ lua        â”‚ â””â”€â”€â”€ http        â”‚
â”‚ â””â”€â”€â”€ http        â”‚                 â”‚                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              Buffer & Routing Engine                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ—ï¸ FluentBit in Kubernetes Architecture

### EKS FluentBit Deployment
```yaml
# FluentBit DaemonSet for EKS
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluent-bit
  namespace: amazon-cloudwatch
  labels:
    k8s-app: fluent-bit
spec:
  selector:
    matchLabels:
      name: fluent-bit
  template:
    metadata:
      labels:
        name: fluent-bit
    spec:
      containers:
      - name: fluent-bit
        image: public.ecr.aws/aws-observability/aws-for-fluent-bit:stable
        imagePullPolicy: Always
        env:
        - name: AWS_REGION
          valueFrom:
            configMapKeyRef:
              name: fluent-bit-cluster-info
              key: logs.region
        - name: CLUSTER_NAME
          valueFrom:
            configMapKeyRef:
              name: fluent-bit-cluster-info
              key: cluster.name
        - name: HTTP_SERVER
          value: "On"
        - name: HTTP_PORT
          value: "2020"
        - name: READ_FROM_HEAD
          value: "Off"
        - name: READ_FROM_TAIL
          value: "On"
        resources:
          limits:
            memory: 200Mi
          requests:
            cpu: 500m
            memory: 100Mi
        volumeMounts:
        - name: fluentbitstate
          mountPath: /var/fluent-bit/state
        - name: varlog
          mountPath: /var/log
          readOnly: true
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
        - name: fluent-bit-config
          mountPath: /fluent-bit/etc/
        - name: runlogjournal
          mountPath: /run/log/journal
          readOnly: true
        - name: dmesg
          mountPath: /var/log/dmesg
          readOnly: true
      terminationGracePeriodSeconds: 10
      volumes:
      - name: fluentbitstate
        hostPath:
          path: /var/fluent-bit/state
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
      - name: fluent-bit-config
        configMap:
          name: fluent-bit-config
      - name: runlogjournal
        hostPath:
          path: /run/log/journal
      - name: dmesg
        hostPath:
          path: /var/log/dmesg
      serviceAccountName: fluent-bit
```

### FluentBit Configuration Structure
```
FluentBit Configuration Flow:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                fluent-bit.conf                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [SERVICE]           # Global settings                   â”‚
â”‚ [INPUT]            # Data sources                       â”‚
â”‚ [FILTER]           # Data processing                     â”‚
â”‚ [OUTPUT]           # Data destinations                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Configuration Files:
â”œâ”€â”€ fluent-bit.conf         # Main configuration
â”œâ”€â”€ parsers.conf           # Log parsing rules  
â”œâ”€â”€ application.conf       # Application-specific config
â””â”€â”€ outputs.conf           # Output configurations
```

## âš™ï¸ FluentBit Configuration

### Main Configuration (fluent-bit.conf)
```ini
[SERVICE]
    Flush         1
    Log_Level     info
    Daemon        off
    Parsers_File  parsers.conf
    HTTP_Server   On
    HTTP_Listen   0.0.0.0
    HTTP_Port     2020
    storage.path              /var/fluent-bit/state/flb-storage/
    storage.sync              normal
    storage.checksum          off
    storage.backlog.mem_limit 5M

# Container logs from Kubernetes nodes
[INPUT]
    Name                tail
    Path                /var/log/containers/*.log
    multiline.parser    docker, cri
    Tag                 kube.*
    Refresh_Interval    5
    Mem_Buf_Limit       50MB
    Skip_Long_Lines     On
    Skip_Empty_Lines    On

# System logs
[INPUT]
    Name                systemd
    Tag                 host.*
    Systemd_Filter      _SYSTEMD_UNIT=docker.service
    Systemd_Filter      _SYSTEMD_UNIT=kubelet.service
    Read_From_Tail      On

# Application logs (custom input)
[INPUT]
    Name                tail
    Path                /var/log/app/*.log
    Tag                 app.*
    Parser              json
    Refresh_Interval    5
    Mem_Buf_Limit       5MB

# Kubernetes metadata filter
[FILTER]
    Name                kubernetes
    Match               kube.*
    Kube_URL            https://kubernetes.default.svc:443
    Kube_CA_File        /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
    Kube_Token_File     /var/run/secrets/kubernetes.io/serviceaccount/token
    Kube_Tag_Prefix     kube.var.log.containers.
    Merge_Log           On
    Merge_Log_Key       log_processed
    K8S-Logging.Parser  On
    K8S-Logging.Exclude Off

# Log parsing and modification
[FILTER]
    Name                parser
    Match               kube.*
    Key_Name            log
    Parser              docker
    Reserve_Data        On

# Add custom fields
[FILTER]
    Name                record_modifier
    Match               kube.*
    Record              cluster_name ${CLUSTER_NAME}
    Record              region ${AWS_REGION}

# CloudWatch Logs output
[OUTPUT]
    Name                cloudwatch_logs
    Match               kube.*
    region              ${AWS_REGION}
    log_group_name      /aws/eks/cluster/application
    log_stream_prefix   ${HOSTNAME}-
    auto_create_group   true
    extra_user_agent    container-insights

# Host logs to separate log group
[OUTPUT]
    Name                cloudwatch_logs
    Match               host.*
    region              ${AWS_REGION}
    log_group_name      /aws/eks/cluster/host
    log_stream_prefix   ${HOSTNAME}-system-
    auto_create_group   true

# Application logs with custom routing
[OUTPUT]
    Name                cloudwatch_logs
    Match               app.*
    region              ${AWS_REGION}
    log_group_name      /aws/application/backend
    log_stream_prefix   app-
    auto_create_group   true
```

### Parsers Configuration (parsers.conf)
```ini
# Docker container logs parser
[PARSER]
    Name        docker
    Format      json
    Time_Key    time
    Time_Format %Y-%m-%dT%H:%M:%S.%L
    Time_Keep   On

# JSON application logs parser
[PARSER]
    Name        json
    Format      json
    Time_Key    timestamp
    Time_Format %Y-%m-%dT%H:%M:%S.%fZ
    Time_Keep   On

# Nginx access logs parser
[PARSER]
    Name        nginx
    Format      regex
    Regex       ^(?<remote>[^ ]*) (?<host>[^ ]*) (?<user>[^ ]*) \[(?<time>[^\]]*)\] "(?<method>\S+)(?: +(?<path>[^\"]*?)(?: +\S*)?)?" (?<code>[^ ]*) (?<size>[^ ]*)(?: "(?<referer>[^\"]*)" "(?<agent>[^\"]*)")?$
    Time_Key    time
    Time_Format %d/%b/%Y:%H:%M:%S %z

# Custom application parser
[PARSER]
    Name        myapp
    Format      regex
    Regex       ^\[(?<timestamp>[^\]]*)\] (?<level>\w+) (?<logger>[^ ]*) - (?<message>.*)$
    Time_Key    timestamp
    Time_Format %Y-%m-%d %H:%M:%S,%f

# Multi-line Java stack trace parser
[MULTILINE_PARSER]
    name          java
    type          regex
    flush_timeout 1000
    rule      "start_state"   "/((\d{4}-)|\d{1,2}(\s+\w+){2}\s+\d{4}|(\w+\s+){2}\d{1,2}\s+\d{4}).*/"  "cont"
    rule      "cont"          "/^\s+at\s+.*/"                                                              "cont"
    rule      "cont"          "/^\s*Caused by:.*/"                                                        "cont"

# Multi-line Python traceback parser
[MULTILINE_PARSER]
    name          python
    type          regex
    flush_timeout 1000
    rule      "start_state"   "/^Traceback \(most recent call last\):.*/"  "traceback"
    rule      "traceback"     "/^\s+File.*/"                                "traceback"
    rule      "traceback"     "/^\s+\w+.*/"                                 "traceback"
    rule      "traceback"     "/^\w+Error:.*/"                             "exception"
```

## ğŸ”„ Log Flow Architecture

### Log Collection Flow
```
Log Collection Architecture:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Kubernetes Cluster                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Pod Logs â†’ Container Runtime â†’ Node Filesystem             â”‚
â”‚     â”œâ”€â”€ /var/log/containers/*.log                         â”‚
â”‚     â”œâ”€â”€ /var/log/pods/*/*/*.log                           â”‚
â”‚     â””â”€â”€ /var/lib/docker/containers/*/json.log             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     FluentBit                              â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Input  â†’ Filter â†’ Buffer â†’ Output                      â”‚ â”‚
â”‚ â”‚   â†“        â†“        â†“        â†“                          â”‚ â”‚
â”‚ â”‚ tail    k8s meta  memory   cloudwatch                   â”‚ â”‚
â”‚ â”‚ systemd  parser   disk     s3                          â”‚ â”‚
â”‚ â”‚ tcp      grep    network   kinesis                      â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                        AWS                                  â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ CloudWatch Logs â†’ Insights â†’ Dashboards                â”‚ â”‚
â”‚ â”‚ S3 Storage      â†’ Analytics                             â”‚ â”‚
â”‚ â”‚ Kinesis Streams â†’ Real-time Processing                 â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Kubernetes Metadata Enrichment
```yaml
# Original container log
{
  "log": "2024-02-03 14:30:25 INFO Started application",
  "stream": "stdout",
  "time": "2024-02-03T14:30:25.123456Z"
}

# After Kubernetes filter enrichment
{
  "log": "2024-02-03 14:30:25 INFO Started application",
  "stream": "stdout", 
  "time": "2024-02-03T14:30:25.123456Z",
  "kubernetes": {
    "pod_name": "myapp-deployment-7d4f8b5c8-xyz12",
    "namespace_name": "production",
    "pod_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "labels": {
      "app": "myapp",
      "version": "1.2.3",
      "environment": "production"
    },
    "annotations": {
      "deployment.kubernetes.io/revision": "1"
    },
    "host": "ip-10-0-1-123.ec2.internal",
    "container_name": "myapp",
    "docker_id": "1234567890abcdef...",
    "container_hash": "myapp@sha256:abcdef...",
    "container_image": "myapp:1.2.3"
  }
}
```

## ğŸ” Advanced Configuration Patterns

### Multi-Environment Log Routing
```ini
# Development environment routing
[FILTER]
    Name                grep
    Match               kube.*
    Regex               kubernetes.namespace_name development

[OUTPUT]
    Name                cloudwatch_logs
    Match_Regex         kube.*development.*
    region              ${AWS_REGION}
    log_group_name      /aws/eks/dev-cluster
    log_stream_prefix   dev-
    auto_create_group   true

# Production environment routing
[FILTER]
    Name                grep
    Match               kube.*
    Regex               kubernetes.namespace_name production

[OUTPUT]
    Name                cloudwatch_logs
    Match_Regex         kube.*production.*
    region              ${AWS_REGION}
    log_group_name      /aws/eks/prod-cluster
    log_stream_prefix   prod-
    auto_create_group   true
```

### Log Level Based Routing
```ini
# Error logs to separate log group
[FILTER]
    Name                parser
    Match               app.*
    Key_Name            log
    Parser              json
    Reserve_Data        On

[FILTER]
    Name                grep
    Match               app.*
    Regex               level (ERROR|FATAL)

[OUTPUT]
    Name                cloudwatch_logs
    Match               app.*
    region              ${AWS_REGION}
    log_group_name      /aws/application/errors
    log_stream_prefix   error-
    auto_create_group   true

# All other logs
[FILTER]
    Name                grep
    Match               app.*
    Regex               level (INFO|DEBUG|WARN)
    
[OUTPUT]
    Name                cloudwatch_logs
    Match               app.*
    region              ${AWS_REGION}
    log_group_name      /aws/application/general
    log_stream_prefix   app-
    auto_create_group   true
```

### Performance Optimization Configuration
```ini
[SERVICE]
    # Buffer configuration
    storage.path              /var/fluent-bit/state/flb-storage/
    storage.sync              normal
    storage.checksum          off
    storage.backlog.mem_limit 10M
    storage.max_chunks_up     128
    
    # Performance tuning
    flush                     5
    grace                     30
    daemon                    off
    
    # Resource limits
    log_level                 warn
    parsers_file              parsers.conf

[INPUT]
    Name                tail
    Path                /var/log/containers/*.log
    Tag                 kube.*
    
    # Performance settings
    Refresh_Interval    10
    Rotate_Wait         5
    Skip_Long_Lines     On
    Skip_Empty_Lines    On
    
    # Buffer limits
    Mem_Buf_Limit       50MB
    Buffer_Chunk_Size   32k
    Buffer_Max_Size     5MB
    
    # Multi-line handling
    multiline.parser    docker, cri
    
[OUTPUT]
    Name                cloudwatch_logs
    Match               *
    region              ${AWS_REGION}
    
    # Batch settings for performance
    log_retention_days  7
    auto_create_group   true
    
    # Retry configuration
    retry_limit         3
    workers             4
```

## ğŸ› ï¸ Troubleshooting FluentBit

### Common Issues and Solutions

#### 1. Logs Not Appearing in CloudWatch
```bash
# Check FluentBit status
kubectl get pods -n amazon-cloudwatch

# View FluentBit logs
kubectl logs -n amazon-cloudwatch fluent-bit-xxxxx -f

# Common issues:
# - IAM permissions missing
# - AWS region configuration
# - Log group creation permissions
# - Network connectivity
```

#### 2. High Memory Usage
```ini
# Optimize memory usage
[INPUT]
    Name                tail
    Path                /var/log/containers/*.log
    Tag                 kube.*
    Mem_Buf_Limit       50MB      # Reduce if needed
    Buffer_Chunk_Size   32k       # Smaller chunks
    Buffer_Max_Size     5MB       # Limit buffer size
    Skip_Long_Lines     On        # Skip problematic lines
    Skip_Empty_Lines    On        # Reduce processing

[SERVICE]
    storage.backlog.mem_limit 5M  # Limit backlog memory
    storage.max_chunks_up     64  # Reduce concurrent chunks
```

#### 3. Log Parsing Issues
```bash
# Debug parser configuration
kubectl exec -n amazon-cloudwatch fluent-bit-xxxxx -- /fluent-bit/bin/fluent-bit --dry-run --config=/fluent-bit/etc/fluent-bit.conf

# Test parser manually
echo '{"timestamp":"2024-02-03T14:30:25.123Z","level":"INFO","message":"Test"}' | /fluent-bit/bin/fluent-bit --config=test.conf

# Common parser issues:
# - Time format mismatches
# - Regex pattern errors
# - Field name conflicts
# - Multi-line configuration
```

#### 4. Performance Issues
```bash
# Monitor FluentBit metrics
curl http://localhost:2020/api/v1/metrics/prometheus

# Key metrics to monitor:
# - fluentbit_input_records_total
# - fluentbit_output_records_total  
# - fluentbit_output_errors_total
# - fluentbit_output_retries_total

# Performance tuning:
# - Adjust flush intervals
# - Optimize parsers
# - Configure proper buffering
# - Use multiple workers
```

### FluentBit Health Monitoring
```yaml
# Health check configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
  namespace: amazon-cloudwatch
data:
  fluent-bit.conf: |
    [SERVICE]
        HTTP_Server  On
        HTTP_Listen  0.0.0.0
        HTTP_PORT    2020
        Health_Check On
        HC_Errors_Count 5
        HC_Retry_Failure_Count 5
        HC_Period 60

  monitoring.conf: |
    [INPUT]
        Name              http
        Port              8080
        Host              0.0.0.0

    [OUTPUT]
        Name              http
        Match             *
        Host              monitoring.example.com
        Port              443
        URI               /fluent-bit-logs
        tls               On
```

## ğŸ“Š FluentBit Monitoring and Metrics

### Built-in Metrics
```bash
# Access FluentBit metrics endpoint
curl http://fluent-bit-pod:2020/api/v1/metrics/prometheus

# Sample metrics output:
fluentbit_input_records_total{name="tail.0"} 12345
fluentbit_input_bytes_total{name="tail.0"} 1234567
fluentbit_output_records_total{name="cloudwatch_logs.0"} 12300
fluentbit_output_bytes_total{name="cloudwatch_logs.0"} 1230000
fluentbit_output_errors_total{name="cloudwatch_logs.0"} 5
fluentbit_output_retries_total{name="cloudwatch_logs.0"} 15
```

### Custom Monitoring Setup
```yaml
# Prometheus monitoring for FluentBit
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: fluent-bit
  namespace: amazon-cloudwatch
spec:
  selector:
    matchLabels:
      name: fluent-bit
  endpoints:
  - port: http
    interval: 30s
    path: /api/v1/metrics/prometheus

---
apiVersion: v1
kind: Service
metadata:
  name: fluent-bit-metrics
  namespace: amazon-cloudwatch
  labels:
    name: fluent-bit
spec:
  ports:
  - name: http
    port: 2020
    targetPort: 2020
  selector:
    name: fluent-bit
```

## ğŸ§ª FluentBit Testing and Validation

### Configuration Testing
```bash
# Validate configuration syntax
fluent-bit --dry-run --config=/fluent-bit/etc/fluent-bit.conf

# Test with sample data
echo '{"timestamp":"2024-02-03T14:30:25.123Z","level":"INFO","message":"Test"}' | \
fluent-bit --config=/fluent-bit/etc/fluent-bit.conf --input=stdin --output=stdout

# Debug mode for troubleshooting
fluent-bit --config=/fluent-bit/etc/fluent-bit.conf --verbose
```

### Local Development Setup
```yaml
# Docker Compose for local FluentBit testing
version: '3.8'
services:
  fluent-bit:
    image: fluent/fluent-bit:latest
    volumes:
      - ./fluent-bit.conf:/fluent-bit/etc/fluent-bit.conf
      - ./parsers.conf:/fluent-bit/etc/parsers.conf
      - ./logs:/var/log
    ports:
      - "2020:2020"
    environment:
      - AWS_REGION=us-west-2
      - AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
      - AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}

  log-generator:
    image: mingrammer/flog:latest
    command: >
      --format=json
      --number=0
      --delay=1s
      --output=/var/log/app.log
    volumes:
      - ./logs:/var/log
```

## ğŸ“‹ Best Practices Summary

### Configuration Best Practices
```ini
# âœ… DO: Use appropriate buffer limits
Mem_Buf_Limit       50MB
Buffer_Chunk_Size   32k

# âœ… DO: Configure retry logic
retry_limit         3
retry_limit_cycle   no

# âœ… DO: Use health checks
HTTP_Server         On
Health_Check        On

# âŒ DON'T: Use excessive verbosity in production
Log_Level           warn  # not debug

# âŒ DON'T: Skip error handling
# Always configure retry and error handling
```

### Performance Best Practices
```
Resource Optimization:
âœ… Set appropriate memory limits
âœ… Use storage buffering for reliability  
âœ… Configure proper flush intervals
âœ… Monitor and alert on metrics
âœ… Use multi-worker outputs
âœ… Implement log rotation

Network Optimization:
âœ… Batch log shipments efficiently
âœ… Use compression when possible
âœ… Configure proper timeouts
âœ… Implement circuit breakers
```

## ğŸ“ Practice Exercises

### Exercise 1: Basic Configuration
1. **Deploy FluentBit** to a Kubernetes cluster
2. **Configure log collection** from containers
3. **Set up CloudWatch** log group creation
4. **Verify logs** are appearing in CloudWatch

### Exercise 2: Advanced Parsing
1. **Create custom parsers** for your application logs
2. **Configure multi-line** log handling
3. **Test parser configuration** with sample data
4. **Troubleshoot parsing** issues

### Exercise 3: Log Routing
1. **Set up environment-based** log routing
2. **Configure log level** separation
3. **Create custom filters** for log processing
4. **Monitor routing** effectiveness

### Exercise 4: Performance Tuning
1. **Optimize FluentBit** resource usage
2. **Configure buffering** strategies
3. **Set up monitoring** and alerting
4. **Load test** log processing capacity

## â¡ï¸ Next Steps
Now that you understand FluentBit architecture and configuration, proceed to [9. Advanced-CloudWatch-Queries.md](9.%20Advanced-CloudWatch-Queries.md) to master advanced querying techniques for error filtering, log aggregation, and performance analysis.