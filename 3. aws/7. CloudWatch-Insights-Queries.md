# 7. CloudWatch Insights Queries

## üéØ Learning Objectives
- [ ] Master CloudWatch Insights query syntax
- [ ] Understand query structure and commands
- [ ] Learn to filter, parse, and analyze log data
- [ ] Create effective queries for troubleshooting
- [ ] Build reusable query patterns for common scenarios

## üìã CloudWatch Insights Overview

### What is CloudWatch Insights?
```
CloudWatch Insights is a log analysis service that provides:
‚úÖ Interactive log exploration
‚úÖ Purpose-built query language
‚úÖ Real-time log analysis
‚úÖ Visualization capabilities
‚úÖ Automatic field discovery
‚úÖ Scalable log processing
```

### Query Language Structure
```sql
-- Basic query structure
fields @timestamp, @message
| filter @message like /ERROR/
| sort @timestamp desc
| limit 20

-- Components explained:
fields      - Select specific fields to display
filter      - Apply conditions to filter logs
sort        - Order results by field
limit       - Restrict number of results
stats       - Aggregate and calculate statistics
parse       - Extract fields from text
```

### Accessing CloudWatch Insights
```
Navigation Path:
AWS Console ‚Üí CloudWatch ‚Üí Logs ‚Üí Insights

Query Interface:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Select log group(s): [/myapp/backend ‚ñº]        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Query Editor:                                   ‚îÇ
‚îÇ fields @timestamp, @message                     ‚îÇ
‚îÇ | filter @message like /ERROR/                  ‚îÇ
‚îÇ | sort @timestamp desc                          ‚îÇ
‚îÇ | limit 20                                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ [Run query] Time range: [Last 1 hour ‚ñº]       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Results: 42 records | Scanned: 1.2M records   ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ ‚îÇ @timestamp        ‚îÇ @message             ‚îÇ   ‚îÇ
‚îÇ ‚îÇ 2024-02-03 14:35  ‚îÇ ERROR: DB timeout    ‚îÇ   ‚îÇ
‚îÇ ‚îÇ 2024-02-03 14:32  ‚îÇ ERROR: Auth failed   ‚îÇ   ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üîç Basic Query Syntax

### Field Selection
```sql
-- Select all fields
fields @timestamp, @message, @logStream

-- Select built-in fields
fields @timestamp, @message, @requestId

-- Select custom fields (from JSON logs)
fields @timestamp, level, message, userId, requestId

-- Display all available fields
fields @timestamp, @message
| limit 1
```

### Built-in Fields
```sql
-- Common built-in fields:
@timestamp      -- Event timestamp
@message        -- Log message content
@logStream      -- Log stream name
@log           -- Log group name
@requestId     -- Request identifier (when available)
@memoryUsed    -- Memory usage (Lambda)
@duration      -- Execution duration (Lambda)
@billedDuration -- Billed duration (Lambda)
@maxMemoryUsed -- Max memory used (Lambda)
```

### Time Range Selection
```sql
-- Relative time ranges
-- Last 5 minutes, 1 hour, 1 day, 1 week

-- Absolute time ranges
-- From: 2024-02-03T14:00:00Z
-- To: 2024-02-03T15:00:00Z

-- Query with time filter
fields @timestamp, @message
| filter @timestamp >= dateadd(hour, -1, now())
| sort @timestamp desc
```

## üîß Filtering and Searching

### Basic Text Filtering
```sql
-- Case-sensitive exact match
fields @timestamp, @message
| filter @message = "ERROR"

-- Case-insensitive search
fields @timestamp, @message
| filter @message like /error/i

-- Contains text
fields @timestamp, @message
| filter @message like /timeout/

-- Multiple conditions (AND)
fields @timestamp, @message
| filter @message like /ERROR/ and @timestamp > dateadd(hour, -1, now())

-- Multiple conditions (OR)
fields @timestamp, @message
| filter @message like /ERROR/ or @message like /WARN/
```

### Pattern Matching
```sql
-- Wildcard patterns
fields @timestamp, @message
| filter @message like /^ERROR:/

-- Regular expressions
fields @timestamp, @message
| filter @message like /HTTP [45]\d\d/

-- Negation
fields @timestamp, @message
| filter @message not like /DEBUG/
```

### Field-Based Filtering
```sql
-- JSON field filtering
fields @timestamp, level, message, statusCode
| filter level = "ERROR"
| filter statusCode >= 400

-- Numeric comparisons
fields @timestamp, @message, @duration
| filter @duration > 10000

-- String field operations
fields @timestamp, userId, action
| filter userId like /user-12*/
| filter action in ["login", "logout"]
```

## üìä Parsing and Field Extraction

### Parse Command Basics
```sql
-- Extract fields from unstructured text
fields @timestamp, @message
| parse @message "[*] * - *" as level, timestamp, content
| filter level = "ERROR"

-- Parse with named groups
fields @timestamp, @message
| parse @message /^(?<level>[A-Z]+):\s+(?<content>.+)$/
| filter level in ["ERROR", "FATAL"]
```

### Common Parsing Patterns
```sql
-- HTTP access logs
fields @timestamp, @message
| parse @message "* * [*] \"* * *\" * *" as ip, user, timestamp, method, path, protocol, status, size
| filter status >= 400

-- Application logs with JSON
fields @timestamp, @message
| parse @message /(?<json>\{.*\})/
| filter json like /error/

-- Docker/Kubernetes logs
fields @timestamp, @message
| parse @message "* * *" as timestamp, level, content
| filter level = "ERROR"

-- CodeBuild logs
fields @timestamp, @message
| parse @message "[Container] * * *" as date, time, command
| filter command like /FAILED/
```

### JSON Log Parsing
```sql
-- For structured JSON logs
fields @timestamp, level, message, error, userId, requestId
| filter level = "error"
| filter ispresent(error.code)
| sort @timestamp desc

-- Extract nested JSON fields
fields @timestamp, request.method, request.path, response.statusCode, response.duration
| filter response.statusCode >= 400
| stats count() by request.path
```

## üìà Statistics and Aggregation

### Count Operations
```sql
-- Simple count
fields @message
| filter @message like /ERROR/
| stats count()

-- Count by field
fields level
| stats count() by level

-- Count with time binning
fields @timestamp
| filter @message like /ERROR/
| stats count() by bin(5m)
```

### Statistical Functions
```sql
-- Basic statistics
fields @duration
| stats avg(@duration), max(@duration), min(@duration), sum(@duration)

-- Percentiles
fields @duration
| stats avg(@duration), pct(@duration, 50), pct(@duration, 95), pct(@duration, 99)

-- Count distinct
fields userId
| stats count_distinct(userId)

-- Multiple aggregations
fields statusCode, @duration
| stats count() as requests, avg(@duration) as avg_duration by statusCode
| sort requests desc
```

### Time-Based Aggregation
```sql
-- Aggregate by time intervals
fields @timestamp, @message
| filter @message like /ERROR/
| stats count() as error_count by bin(1h)
| sort @timestamp

-- Multiple metrics over time
fields @timestamp, level, @duration
| stats count() as total_requests, 
        count(level="ERROR") as errors,
        avg(@duration) as avg_duration 
  by bin(5m)
| sort @timestamp desc
```

## üîé Advanced Query Patterns

### Error Analysis Queries
```sql
-- Top error messages
fields @message
| filter @message like /ERROR/
| stats count() as error_count by @message
| sort error_count desc
| limit 10

-- Error rate over time
fields @timestamp, level
| stats count(level="ERROR") as errors, count() as total by bin(5m)
| eval error_rate = errors / total * 100
| sort @timestamp desc

-- Errors by service component
fields @logStream, @message
| filter @message like /ERROR/
| parse @logStream /(?<service>[^-]+)-(?<instance>.*)/
| stats count() as error_count by service
| sort error_count desc
```

### Performance Analysis
```sql
-- Slow request analysis
fields @timestamp, @duration, @requestId
| filter @duration > 10000
| sort @duration desc
| limit 20

-- Response time percentiles
fields @duration
| filter ispresent(@duration)
| stats avg(@duration) as avg_response_time,
        pct(@duration, 50) as p50,
        pct(@duration, 95) as p95,
        pct(@duration, 99) as p99

-- Performance by endpoint
fields request.path, @duration
| filter ispresent(request.path) and ispresent(@duration)
| stats count() as requests,
        avg(@duration) as avg_duration,
        pct(@duration, 95) as p95_duration
  by request.path
| sort avg_duration desc
```

### User Behavior Analysis
```sql
-- Active users over time
fields @timestamp, userId
| filter ispresent(userId)
| stats count_distinct(userId) as active_users by bin(1h)
| sort @timestamp desc

-- User activity patterns
fields userId, action
| filter ispresent(userId) and ispresent(action)
| stats count() as activity_count by userId, action
| sort activity_count desc
| limit 50

-- Failed login attempts
fields @timestamp, userId, action, status
| filter action = "login" and status = "failed"
| stats count() as failed_attempts by userId
| sort failed_attempts desc
| limit 20
```

### System Resource Monitoring
```sql
-- Memory usage analysis (Lambda)
fields @timestamp, @memoryUsed, @maxMemoryUsed
| filter ispresent(@memoryUsed)
| stats avg(@memoryUsed) as avg_memory,
        max(@maxMemoryUsed) as peak_memory,
        pct(@memoryUsed, 95) as p95_memory
  by bin(5m)

-- Cold start analysis (Lambda)
fields @timestamp, @duration, @message
| filter @message like /INIT_START/
| stats count() as cold_starts by bin(1h)
| sort @timestamp desc

-- Resource utilization trends
fields @timestamp, cpu_percent, memory_percent
| stats avg(cpu_percent) as avg_cpu,
        avg(memory_percent) as avg_memory,
        max(cpu_percent) as peak_cpu
  by bin(10m)
```

## üõ†Ô∏è Practical Query Examples

### CodeBuild Log Analysis
```sql
-- Find failed builds
fields @timestamp, @message
| filter @message like /FAILED/
| parse @message "[Container] * * Phase complete: * State: FAILED*" as date, time, phase
| stats count() as failures by phase
| sort failures desc

-- Build duration analysis
fields @timestamp, @message
| filter @message like /Duration:/
| parse @message "Duration: *" as duration
| stats avg(duration) as avg_duration,
        max(duration) as max_duration,
        min(duration) as min_duration

-- Error patterns in builds
fields @timestamp, @message
| filter @message like /npm ERR!/ or @message like /Command did not exit successfully/
| stats count() as error_count by @message
| sort error_count desc
| limit 10
```

### API Gateway Log Analysis
```sql
-- HTTP status code distribution
fields status, requestId
| stats count() as request_count by status
| sort request_count desc

-- High latency requests
fields @timestamp, responseTime, requestId, path
| filter responseTime > 5000
| sort responseTime desc
| limit 20

-- Error rate by endpoint
fields path, status
| stats count() as total_requests,
        count(status >= 400) as error_requests
  by path
| eval error_rate = error_requests / total_requests * 100
| sort error_rate desc
```

### Lambda Function Monitoring
```sql
-- Memory utilization analysis
fields @timestamp, @memoryUsed, @maxMemoryUsed, @requestId
| filter ispresent(@memoryUsed)
| stats avg(@memoryUsed) as avg_memory,
        max(@maxMemoryUsed) as peak_memory
  by bin(1h)
| sort @timestamp desc

-- Cold start tracking
fields @timestamp, @message, @requestId
| filter @message like /INIT_START/
| stats count() as cold_starts by bin(15m)

-- Function errors and timeouts
fields @timestamp, @message, @requestId
| filter @message like /Task timed out/ or @message like /Runtime.ExitError/
| stats count() as issues by @message
| sort issues desc
```

## üéØ Query Optimization Tips

### Performance Optimization
```sql
-- Use specific time ranges
fields @timestamp, @message
| filter @timestamp >= dateadd(hour, -2, now())  -- Limit time scope
| filter @message like /ERROR/                    -- Filter early
| limit 100                                       -- Limit results

-- Filter before parsing
fields @timestamp, @message
| filter @message like /HTTP/        -- Filter first
| parse @message "* * *" as method, path, status   -- Then parse
| filter status >= 400               -- Filter on parsed fields
```

### Query Structure Best Practices
```sql
-- Efficient query structure:
-- 1. Select necessary fields only
fields @timestamp, level, message, userId

-- 2. Filter as early as possible
| filter @timestamp >= dateadd(hour, -1, now())
| filter level in ["ERROR", "WARN"]

-- 3. Parse after initial filtering
| parse message /User (?<user_id>\w+) performed (?<action>\w+)/

-- 4. Apply additional filters on parsed fields
| filter action = "login"

-- 5. Aggregate and sort
| stats count() as login_attempts by user_id
| sort login_attempts desc

-- 6. Limit results
| limit 50
```

### Cost Optimization
```sql
-- Minimize data scanned:
-- ‚úÖ Use specific log groups
-- ‚úÖ Use narrow time ranges  
-- ‚úÖ Filter early in the query
-- ‚úÖ Use limit to reduce results
-- ‚úÖ Cache frequent query results

-- ‚ùå Avoid full log group scans
-- ‚ùå Don't use overly broad time ranges
-- ‚ùå Don't fetch all fields unnecessarily
```

## üìù Practice Exercises

### Exercise 1: Basic Queries
1. **Write queries** to find errors in the last hour
2. **Filter logs** by specific log streams
3. **Parse structured log messages**
4. **Count events** by different criteria

### Exercise 2: Statistical Analysis  
1. **Calculate error rates** over time
2. **Find response time percentiles**
3. **Analyze user activity patterns**
4. **Create performance dashboards**

### Exercise 3: Advanced Troubleshooting
1. **Correlate logs** across multiple services
2. **Build complex parsing patterns**
3. **Create custom metrics** from log data
4. **Optimize query performance**

### Exercise 4: Real-world Scenarios
1. **Debug application errors** using log analysis
2. **Monitor system performance** trends
3. **Track user behavior** patterns
4. **Build operational dashboards**

## üéì Query Patterns Library

### Save and Reuse Queries
```sql
-- Error Monitoring Template
fields @timestamp, @message, @logStream
| filter @message like /ERROR/
| filter @timestamp >= dateadd(hour, -4, now())
| stats count() as error_count by @logStream, bin(30m)
| sort @timestamp desc

-- Performance Monitoring Template  
fields @timestamp, @duration, @requestId
| filter ispresent(@duration) and @duration > 1000
| stats avg(@duration) as avg_duration,
        pct(@duration, 95) as p95_duration,
        count() as slow_requests
  by bin(15m)
| sort @timestamp desc

-- User Activity Template
fields @timestamp, userId, action, status
| filter ispresent(userId) and ispresent(action)
| filter @timestamp >= dateadd(hour, -24, now())
| stats count() as actions,
        count_distinct(userId) as unique_users
  by action, status, bin(1h)
| sort @timestamp desc
```

### Query Automation
```python
# Python script to run CloudWatch Insights queries
import boto3
import json
from datetime import datetime, timedelta

def run_insights_query(log_group, query_string, start_time, end_time):
    logs_client = boto3.client('logs')
    
    response = logs_client.start_query(
        logGroupName=log_group,
        startTime=int(start_time.timestamp()),
        endTime=int(end_time.timestamp()),
        queryString=query_string
    )
    
    query_id = response['queryId']
    
    # Poll for results
    while True:
        result = logs_client.get_query_results(queryId=query_id)
        if result['status'] == 'Complete':
            return result['results']
        time.sleep(1)

# Example usage
end_time = datetime.now()
start_time = end_time - timedelta(hours=1)

query = """
fields @timestamp, @message
| filter @message like /ERROR/
| stats count() by bin(5m)
"""

results = run_insights_query('/myapp/backend', query, start_time, end_time)
print(json.dumps(results, indent=2))
```

## ‚û°Ô∏è Next Steps
Now that you master CloudWatch Insights queries, proceed to [8. FluentBit-Architecture.md](8.%20FluentBit-Architecture.md) to understand FluentBit's log forwarding architecture and how logs flow from your applications to CloudWatch.