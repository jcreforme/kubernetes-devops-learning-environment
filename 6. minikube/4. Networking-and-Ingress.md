# 4. Networking and Ingress

## üéØ Learning Objectives
- [ ] Master minikube networking concepts and configuration
- [ ] Implement ingress controllers for external access
- [ ] Configure load balancing and service mesh integration
- [ ] Set up DNS and service discovery
- [ ] Troubleshoot networking issues and optimize performance

## üìã Prerequisites
- Minikube cluster running with adequate resources
- Understanding of Kubernetes networking concepts
- kubectl configured and functional
- Basic knowledge of DNS, HTTP, and networking protocols

## üåê Step 1: Minikube Networking Architecture

### Understanding Minikube Network Components
```bash
# Create networking overview script
cat << 'EOF' > networking-overview.sh
#!/bin/bash

echo "üåê Minikube Networking Overview"
echo "==============================="

# Get minikube IP and cluster information
MINIKUBE_IP=$(minikube ip)
CLUSTER_CIDR=$(kubectl cluster-info dump | grep -o 'cluster-cidr=[^"]*' | cut -d= -f2)
SERVICE_CIDR=$(kubectl cluster-info dump | grep -o 'service-cluster-ip-range=[^"]*' | cut -d= -f2)

echo "üñ•Ô∏è  Cluster Information:"
echo "   Minikube IP: $MINIKUBE_IP"
echo "   Cluster CIDR: ${CLUSTER_CIDR:-Default}"
echo "   Service CIDR: ${SERVICE_CIDR:-Default}"

echo ""
echo "üîç Network Interfaces (inside minikube):"
minikube ssh -- ip addr show

echo ""
echo "üîç Routing Table (inside minikube):"
minikube ssh -- route -n

echo ""
echo "üåê Active Network Services:"
kubectl get services --all-namespaces -o wide

echo ""
echo "üîå Network Policies:"
kubectl get networkpolicies --all-namespaces

echo ""
echo "üéØ Endpoints:"
kubectl get endpoints --all-namespaces
EOF

chmod +x networking-overview.sh
./networking-overview.sh
```

### Network Configuration Options
```bash
# Configure custom networking
cat << 'EOF' > configure-networking.sh
#!/bin/bash

PROFILE_NAME=${1:-"network-demo"}

echo "üîß Configuring custom networking for profile: $PROFILE_NAME"

# Start minikube with custom network configuration
minikube start -p $PROFILE_NAME \
  --cpus=3 \
  --memory=6144 \
  --service-cluster-ip-range=10.96.0.0/16 \
  --cluster-cidr=192.168.0.0/16 \
  --dns-domain=local.dev \
  --extra-config=apiserver.service-node-port-range=30000-32767 \
  --extra-config=kubelet.cluster-dns=10.96.0.10

echo "‚úÖ Custom networking configured"

# Switch context
kubectl config use-context $PROFILE_NAME

# Verify configuration
echo "üìä Network Configuration:"
echo "Service CIDR: $(kubectl cluster-info dump | grep -o 'service-cluster-ip-range=[^"]*' | cut -d= -f2)"
echo "Cluster CIDR: $(kubectl cluster-info dump | grep -o 'cluster-cidr=[^"]*' | cut -d= -f2)"
echo "DNS Domain: $(kubectl get configmap coredns -n kube-system -o yaml | grep 'local.dev' || echo 'Default')"
EOF

chmod +x configure-networking.sh
```

## üö™ Step 2: Ingress Controller Setup and Configuration

### Enable and Configure NGINX Ingress
```bash
# Enable ingress addon with custom configuration
minikube addons enable ingress

# Wait for ingress controller to be ready
kubectl wait --namespace ingress-nginx \
  --for=condition=ready pod \
  --selector=app.kubernetes.io/component=controller \
  --timeout=300s

# Configure custom ingress settings
cat << 'EOF' > configure-ingress.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-configuration
  namespace: ingress-nginx
data:
  # Enable CORS
  enable-cors: "true"
  cors-allow-origin: "*"
  cors-allow-methods: "GET, PUT, POST, DELETE, PATCH, OPTIONS"
  cors-allow-headers: "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization"
  
  # SSL Configuration
  ssl-redirect: "false"
  force-ssl-redirect: "false"
  
  # Performance tuning
  worker-processes: "auto"
  max-worker-connections: "16384"
  keep-alive: "75"
  keep-alive-requests: "100"
  
  # Logging
  log-format-upstream: '$remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent" $request_length $request_time [$proxy_upstream_name] [$proxy_alternative_upstream_name] $upstream_addr $upstream_response_length $upstream_response_time $upstream_status $req_id'
  
  # Rate limiting
  rate-limit-rps: "100"
  
  # Client settings
  client-max-body-size: "50m"
  client-body-buffer-size: "1m"
  
  # Proxy settings
  proxy-connect-timeout: "5"
  proxy-send-timeout: "60"
  proxy-read-timeout: "60"
  proxy-body-size: "50m"
---
# Custom ingress class
apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  name: nginx-custom
spec:
  controller: k8s.io/ingress-nginx
EOF

kubectl apply -f configure-ingress.yaml

# Verify ingress controller
kubectl get pods -n ingress-nginx
kubectl get services -n ingress-nginx
```

### Deploy Sample Applications with Ingress
```bash
# Create comprehensive ingress demo
cat << 'EOF' > deploy-ingress-demo.sh
#!/bin/bash

echo "üöÄ Deploying Ingress Demo Applications"
echo "===================================="

# Create demo namespace
kubectl create namespace ingress-demo

# Deploy frontend application
cat << 'FRONTEND_EOF' | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-app
  namespace: ingress-demo
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: nginx
        image: nginx:alpine
        ports:
        - containerPort: 80
        volumeMounts:
        - name: html-volume
          mountPath: /usr/share/nginx/html
      volumes:
      - name: html-volume
        configMap:
          name: frontend-html
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: frontend-html
  namespace: ingress-demo
data:
  index.html: |
    <!DOCTYPE html>
    <html>
    <head><title>Frontend App</title></head>
    <body style="font-family: Arial; text-align: center; padding: 50px;">
        <h1>üåê Frontend Application</h1>
        <p>This is the frontend service accessible via ingress</p>
        <button onclick="callApi()">Call API</button>
        <div id="result"></div>
        <script>
            async function callApi() {
                try {
                    const response = await fetch('/api/health');
                    const data = await response.text();
                    document.getElementById('result').innerHTML = '<p>API Response: ' + data + '</p>';
                } catch (error) {
                    document.getElementById('result').innerHTML = '<p>Error: ' + error + '</p>';
                }
            }
        </script>
    </body>
    </html>
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  namespace: ingress-demo
spec:
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 80
FRONTEND_EOF

# Deploy API backend
cat << 'BACKEND_EOF' | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-app
  namespace: ingress-demo
spec:
  replicas: 2
  selector:
    matchLabels:
      app: api
  template:
    metadata:
      labels:
        app: api
    spec:
      containers:
      - name: api
        image: nginx:alpine
        ports:
        - containerPort: 80
        volumeMounts:
        - name: api-config
          mountPath: /etc/nginx/conf.d
        - name: api-html
          mountPath: /usr/share/nginx/html
      volumes:
      - name: api-config
        configMap:
          name: api-nginx-config
      - name: api-html
        configMap:
          name: api-html
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: api-nginx-config
  namespace: ingress-demo
data:
  default.conf: |
    server {
        listen 80;
        location /health {
            add_header Content-Type text/plain;
            return 200 'API is healthy - $(date)';
        }
        location /api {
            add_header Content-Type application/json;
            return 200 '{"status":"ok","service":"api","timestamp":"$(date)"}';
        }
        location / {
            root /usr/share/nginx/html;
            index index.html;
        }
    }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: api-html
  namespace: ingress-demo
data:
  index.html: |
    <!DOCTYPE html>
    <html>
    <head><title>API Service</title></head>
    <body style="font-family: Arial; text-align: center; padding: 50px;">
        <h1>üîß API Service</h1>
        <p>This is the API backend service</p>
        <ul style="text-align: left; max-width: 300px; margin: 0 auto;">
            <li><a href="/health">Health Check</a></li>
            <li><a href="/api">API Endpoint</a></li>
        </ul>
    </body>
    </html>
---
apiVersion: v1
kind: Service
metadata:
  name: api-service
  namespace: ingress-demo
spec:
  selector:
    app: api
  ports:
  - port: 80
    targetPort: 80
BACKEND_EOF

# Create comprehensive ingress configuration
cat << 'INGRESS_EOF' | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: demo-ingress
  namespace: ingress-demo
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
    nginx.ingress.kubernetes.io/cors-allow-origin: "*"
    nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, OPTIONS"
    nginx.ingress.kubernetes.io/enable-cors: "true"
spec:
  ingressClassName: nginx
  rules:
  - host: demo.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 80
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 80
  - host: api.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 80
INGRESS_EOF

# Wait for deployments to be ready
echo "‚è≥ Waiting for applications to be ready..."
kubectl wait --for=condition=available --timeout=300s deployment/frontend-app -n ingress-demo
kubectl wait --for=condition=available --timeout=300s deployment/api-app -n ingress-demo

# Get ingress information
echo "‚úÖ Demo applications deployed successfully!"
echo ""
echo "üìä Ingress Information:"
kubectl get ingress -n ingress-demo
echo ""
echo "üåê Access URLs:"
MINIKUBE_IP=$(minikube ip)
echo "Frontend: http://$MINIKUBE_IP (Host: demo.local)"
echo "API: http://$MINIKUBE_IP (Host: api.local)"
echo "API Direct: http://$MINIKUBE_IP/api (Host: demo.local)"
echo ""
echo "üí° Add to /etc/hosts (Linux/Mac) or C:\Windows\System32\drivers\etc\hosts (Windows):"
echo "$MINIKUBE_IP demo.local"
echo "$MINIKUBE_IP api.local"
EOF

chmod +x deploy-ingress-demo.sh
./deploy-ingress-demo.sh
```

## üîß Step 3: Advanced Ingress Features

### SSL/TLS Configuration
```bash
# Create SSL/TLS configuration for ingress
cat << 'EOF' > setup-ssl-ingress.sh
#!/bin/bash

echo "üîí Setting up SSL/TLS for Ingress"
echo "================================="

# Create self-signed certificate
openssl req -x509 -newkey rsa:4096 -keyout tls.key -out tls.crt -days 365 -nodes -subj "/CN=demo.local/O=Demo Organization"

# Create TLS secret
kubectl create secret tls demo-tls --cert=tls.crt --key=tls.key -n ingress-demo

# Create HTTPS ingress
cat << 'HTTPS_INGRESS_EOF' | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: demo-https-ingress
  namespace: ingress-demo
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - demo.local
    - api.local
    secretName: demo-tls
  rules:
  - host: demo.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 80
  - host: api.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 80
HTTPS_INGRESS_EOF

echo "‚úÖ HTTPS ingress configured"
echo "üåê Access via: https://demo.local and https://api.local"

# Cleanup certificate files
rm tls.key tls.crt
EOF

chmod +x setup-ssl-ingress.sh
```

### Load Balancing and Advanced Routing
```bash
# Create advanced routing configuration
cat << 'EOF' > advanced-ingress-routing.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: advanced-routing
  namespace: ingress-demo
  annotations:
    # Path-based routing
    nginx.ingress.kubernetes.io/rewrite-target: /$2
    
    # Session affinity
    nginx.ingress.kubernetes.io/affinity: "cookie"
    nginx.ingress.kubernetes.io/session-cookie-name: "route"
    nginx.ingress.kubernetes.io/session-cookie-expires: "86400"
    nginx.ingress.kubernetes.io/session-cookie-max-age: "86400"
    
    # Rate limiting
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
    
    # Custom headers
    nginx.ingress.kubernetes.io/configuration-snippet: |
      add_header X-Served-By $hostname;
      add_header X-Load-Balancer "nginx-ingress";
    
    # Upstream configuration
    nginx.ingress.kubernetes.io/upstream-keepalive-connections: "64"
    nginx.ingress.kubernetes.io/upstream-keepalive-requests: "100"
    
    # Health checks
    nginx.ingress.kubernetes.io/upstream-health-check-path: "/health"
    nginx.ingress.kubernetes.io/upstream-health-check-timeout: "5"
spec:
  ingressClassName: nginx
  rules:
  - host: advanced.local
    http:
      paths:
      # Version-based routing
      - path: /v1(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 80
      - path: /v2(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 80
      # Feature flag routing
      - path: /beta(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 80
      # Default routing
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 80
EOF

kubectl apply -f advanced-ingress-routing.yaml
```

## üîç Step 4: Service Mesh Integration

### Istio Service Mesh Setup
```bash
# Enable Istio addon (if available)
minikube addons list | grep istio

# If istio addon is available
if minikube addons list | grep -q istio; then
    # Enable Istio
    minikube addons enable istio-provisioner
    minikube addons enable istio
    
    # Wait for Istio components
    kubectl wait --for=condition=available --timeout=600s deployment/istiod -n istio-system
    
    # Enable sidecar injection for demo namespace
    kubectl label namespace ingress-demo istio-injection=enabled
    
    # Restart deployments to inject sidecars
    kubectl rollout restart deployment/frontend-app -n ingress-demo
    kubectl rollout restart deployment/api-app -n ingress-demo
fi

# Create Istio configuration
cat << 'EOF' > istio-gateway-config.yaml
apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: demo-gateway
  namespace: ingress-demo
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - demo.local
    - api.local
  - port:
      number: 443
      name: https
      protocol: HTTPS
    hosts:
    - demo.local
    - api.local
    tls:
      mode: SIMPLE
      credentialName: demo-tls
---
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: demo-virtual-service
  namespace: ingress-demo
spec:
  hosts:
  - demo.local
  - api.local
  gateways:
  - demo-gateway
  http:
  - match:
    - uri:
        prefix: /api
    route:
    - destination:
        host: api-service.ingress-demo.svc.cluster.local
        port:
          number: 80
  - match:
    - headers:
        host:
          exact: api.local
    route:
    - destination:
        host: api-service.ingress-demo.svc.cluster.local
        port:
          number: 80
  - route:
    - destination:
        host: frontend-service.ingress-demo.svc.cluster.local
        port:
          number: 80
---
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: demo-destination-rule
  namespace: ingress-demo
spec:
  host: "*.ingress-demo.svc.cluster.local"
  trafficPolicy:
    loadBalancer:
      simple: ROUND_ROBIN
    connectionPool:
      tcp:
        maxConnections: 100
      http:
        http1MaxPendingRequests: 100
        maxRequestsPerConnection: 2
    circuitBreaker:
      consecutiveErrors: 3
      interval: 30s
      baseEjectionTime: 30s
EOF

# Apply Istio configuration if Istio is available
if kubectl get crd gateways.networking.istio.io &> /dev/null; then
    kubectl apply -f istio-gateway-config.yaml
    echo "‚úÖ Istio service mesh configured"
else
    echo "‚ÑπÔ∏è  Istio not available, skipping service mesh configuration"
fi
```

## üåê Step 5: DNS and Service Discovery

### Custom DNS Configuration
```bash
# Configure custom DNS for development
cat << 'EOF' > setup-custom-dns.sh
#!/bin/bash

echo "üîß Setting up Custom DNS Configuration"
echo "====================================="

# Create custom DNS entries
cat << 'DNS_EOF' | kubectl apply -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: coredns-custom
  namespace: kube-system
data:
  local.dev.server: |
    local.dev:53 {
        errors
        health
        ready
        kubernetes cluster.local in-addr.arpa ip6.arpa {
            pods insecure
            fallthrough in-addr.arpa ip6.arpa
        }
        hosts {
            192.168.49.2 demo.local
            192.168.49.2 api.local
            192.168.49.2 advanced.local
            fallthrough
        }
        prometheus :9153
        forward . /etc/resolv.conf
        cache 30
        loop
        reload
        loadbalance
    }
DNS_EOF

# Restart CoreDNS to apply changes
kubectl rollout restart deployment/coredns -n kube-system

# Wait for CoreDNS to be ready
kubectl wait --for=condition=available --timeout=300s deployment/coredns -n kube-system

echo "‚úÖ Custom DNS configured"

# Test DNS resolution
echo "üîç Testing DNS resolution:"
kubectl run dns-test --image=busybox --rm -it --restart=Never -- nslookup demo.local
EOF

chmod +x setup-custom-dns.sh
```

### External DNS Integration
```bash
# Create external DNS simulation
cat << 'EOF' > external-dns-setup.sh
#!/bin/bash

echo "üåç Setting up External DNS Integration"
echo "======================================"

# Deploy external-dns (simulated with local configuration)
cat << 'EXTERNAL_DNS_EOF' | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: external-dns
  namespace: kube-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: external-dns
  template:
    metadata:
      labels:
        app: external-dns
    spec:
      containers:
      - name: external-dns
        image: k8s.gcr.io/external-dns/external-dns:v0.13.1
        args:
        - --source=ingress
        - --domain-filter=local.dev
        - --provider=coredns
        - --log-level=info
        - --log-format=text
        - --dry-run=false
        env:
        - name: ETCD_URLS
          value: "http://localhost:2379"
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: external-dns
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: external-dns
rules:
- apiGroups: [""]
  resources: ["services","endpoints","pods"]
  verbs: ["get","watch","list"]
- apiGroups: ["extensions","networking.k8s.io"]
  resources: ["ingresses"]
  verbs: ["get","watch","list"]
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: external-dns-viewer
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: external-dns
subjects:
- kind: ServiceAccount
  name: external-dns
  namespace: kube-system
EXTERNAL_DNS_EOF

echo "‚úÖ External DNS integration configured"
echo "‚ÑπÔ∏è  This is a simulation for local development"
EOF

chmod +x external-dns-setup.sh
```

## üîß Step 6: Network Troubleshooting and Monitoring

### Network Diagnostic Tools
```bash
# Create comprehensive network diagnostics
cat << 'EOF' > network-diagnostics.sh
#!/bin/bash

echo "üîç Minikube Network Diagnostics"
echo "==============================="

# Get basic network information
echo "1. Cluster Network Information:"
echo "   Minikube IP: $(minikube ip)"
echo "   Cluster CIDR: $(kubectl cluster-info dump | grep -o 'cluster-cidr=[^"]*' | cut -d= -f2 || echo 'Default')"
echo "   Service CIDR: $(kubectl cluster-info dump | grep -o 'service-cluster-ip-range=[^"]*' | cut -d= -f2 || echo 'Default')"

echo ""
echo "2. Ingress Controller Status:"
kubectl get pods -n ingress-nginx
kubectl get services -n ingress-nginx

echo ""
echo "3. Service and Endpoints Status:"
kubectl get services --all-namespaces
echo ""
kubectl get endpoints --all-namespaces

echo ""
echo "4. Ingress Resources:"
kubectl get ingress --all-namespaces

echo ""
echo "5. Network Policies:"
kubectl get networkpolicies --all-namespaces

echo ""
echo "6. DNS Configuration:"
kubectl get configmap coredns -n kube-system -o yaml | grep -A 20 Corefile:

echo ""
echo "7. Network Connectivity Test:"
# Create test pod for connectivity
kubectl run network-test --image=nicolaka/netshoot --rm -it --restart=Never -- /bin/bash -c "
echo 'Testing internal connectivity:'
nslookup kubernetes.default.svc.cluster.local
echo ''
echo 'Testing external connectivity:'
nslookup google.com
echo ''
echo 'Testing ingress connectivity:'
curl -s -o /dev/null -w '%{http_code}' http://$(minikube ip) || echo 'Failed'
"

echo ""
echo "8. Port Status:"
minikube ssh -- netstat -tlnp | grep :80
minikube ssh -- netstat -tlnp | grep :443

echo ""
echo "9. Ingress Controller Logs (last 20 lines):"
kubectl logs -n ingress-nginx deployment/ingress-nginx-controller --tail=20
EOF

chmod +x network-diagnostics.sh
```

### Performance Monitoring
```bash
# Create network performance monitoring
cat << 'EOF' > network-performance-monitor.sh
#!/bin/bash

echo "üìä Network Performance Monitoring"
echo "================================="

# Function to test ingress performance
test_ingress_performance() {
    local url=$1
    local name=$2
    
    echo "üîç Testing $name: $url"
    
    # Use curl to test response times
    times=$(for i in {1..10}; do
        curl -s -o /dev/null -w '%{time_total}\n' "$url"
    done)
    
    # Calculate average
    total=0
    count=0
    for time in $times; do
        total=$(echo "$total + $time" | bc)
        count=$((count + 1))
    done
    
    if [ $count -gt 0 ]; then
        average=$(echo "scale=3; $total / $count" | bc)
        echo "   Average response time: ${average}s"
    else
        echo "   No successful requests"
    fi
    
    echo "   Individual times: $times"
    echo ""
}

# Get minikube IP
MINIKUBE_IP=$(minikube ip)

# Test different endpoints
test_ingress_performance "http://$MINIKUBE_IP" "Frontend (via ingress)"
test_ingress_performance "http://$MINIKUBE_IP/api/health" "API health endpoint"

# Test direct service access
echo "üîç Direct Service Performance:"
kubectl port-forward -n ingress-demo service/frontend-service 8080:80 &
PF_PID=$!
sleep 2

test_ingress_performance "http://localhost:8080" "Frontend (direct service)"

# Cleanup
kill $PF_PID 2>/dev/null

echo "üìà Ingress Controller Resource Usage:"
kubectl top pods -n ingress-nginx

echo ""
echo "üîß Ingress Controller Configuration:"
kubectl get configmap nginx-configuration -n ingress-nginx -o yaml | grep -A 50 data:
EOF

chmod +x network-performance-monitor.sh
```

## üõ†Ô∏è Step 7: Advanced Networking Scenarios

### Multi-Tenant Networking
```bash
# Create multi-tenant networking setup
cat << 'EOF' > multi-tenant-networking.sh
#!/bin/bash

echo "üè¢ Setting up Multi-Tenant Networking"
echo "===================================="

# Create tenant namespaces
tenants=("tenant-a" "tenant-b" "tenant-c")

for tenant in "${tenants[@]}"; do
    echo "Setting up tenant: $tenant"
    
    # Create namespace
    kubectl create namespace $tenant
    
    # Deploy tenant application
    cat << TENANT_EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app
  namespace: $tenant
spec:
  replicas: 1
  selector:
    matchLabels:
      app: tenant-app
  template:
    metadata:
      labels:
        app: tenant-app
        tenant: $tenant
    spec:
      containers:
      - name: nginx
        image: nginx:alpine
        ports:
        - containerPort: 80
        volumeMounts:
        - name: html
          mountPath: /usr/share/nginx/html
      volumes:
      - name: html
        configMap:
          name: tenant-html
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: tenant-html
  namespace: $tenant
data:
  index.html: |
    <h1>$tenant Application</h1>
    <p>This is the application for $tenant</p>
---
apiVersion: v1
kind: Service
metadata:
  name: app-service
  namespace: $tenant
spec:
  selector:
    app: tenant-app
  ports:
  - port: 80
    targetPort: 80
---
# Network policy for tenant isolation
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: tenant-isolation
  namespace: $tenant
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
  - from:
    - namespaceSelector:
        matchLabels:
          name: $tenant
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: kube-system
  - to: []
    ports:
    - protocol: TCP
      port: 53
    - protocol: UDP
      port: 53
TENANT_EOF
    
    # Label namespace for network policies
    kubectl label namespace $tenant name=$tenant
done

# Create multi-tenant ingress
cat << 'INGRESS_EOF' | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: multi-tenant-ingress
  namespace: ingress-nginx
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  rules:
  - host: tenant-a.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app-service
            port:
              number: 80
            namespace: tenant-a
  - host: tenant-b.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app-service
            port:
              number: 80
            namespace: tenant-b
  - host: tenant-c.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app-service
            port:
              number: 80
            namespace: tenant-c
INGRESS_EOF

echo "‚úÖ Multi-tenant networking configured"
echo ""
echo "üåê Access URLs:"
MINIKUBE_IP=$(minikube ip)
for tenant in "${tenants[@]}"; do
    echo "$tenant: http://$MINIKUBE_IP (Host: ${tenant}.local)"
done

echo ""
echo "üí° Add to hosts file:"
for tenant in "${tenants[@]}"; do
    echo "$MINIKUBE_IP ${tenant}.local"
done
EOF

chmod +x multi-tenant-networking.sh
```

## ‚úÖ Success Criteria

### ‚úÖ Networking and Ingress Checklist
- [ ] Understand minikube networking architecture and components
- [ ] Successfully configure and use NGINX ingress controller
- [ ] Implement SSL/TLS termination and advanced routing
- [ ] Set up service mesh integration (if available)
- [ ] Configure custom DNS and service discovery
- [ ] Master network troubleshooting and performance monitoring
- [ ] Implement multi-tenant networking with isolation
- [ ] Optimize ingress performance and security

### ‚úÖ Validation Commands
```bash
# Test all networking components:
./networking-overview.sh
./deploy-ingress-demo.sh
./network-diagnostics.sh
./network-performance-monitor.sh
curl -H "Host: demo.local" http://$(minikube ip)
curl -H "Host: api.local" http://$(minikube ip)/health
```

## üéØ Next Steps

After mastering minikube networking:

1. **Service Mesh Deep Dive** - Advanced Istio configuration and observability
2. **Security Hardening** - Network policies and security best practices
3. **Performance Optimization** - Load balancing and caching strategies
4. **Multi-Cluster Networking** - Cross-cluster communication patterns
5. **Production Migration** - Transitioning from minikube to production clusters

## üìö Key Takeaways

### What You've Learned
1. **Network Architecture**: Understanding minikube's networking model and components
2. **Ingress Management**: Configuring and optimizing ingress controllers
3. **Service Discovery**: DNS configuration and service mesh integration
4. **Security**: Network policies and multi-tenant isolation
5. **Troubleshooting**: Diagnostic tools and performance monitoring

### Best Practices Implemented
- Comprehensive ingress configuration with SSL/TLS
- Performance monitoring and optimization
- Network isolation and security policies
- Service mesh integration for advanced traffic management
- Multi-tenant networking with proper isolation

These networking capabilities provide the foundation for building production-ready applications with proper external access, security, and performance optimization.