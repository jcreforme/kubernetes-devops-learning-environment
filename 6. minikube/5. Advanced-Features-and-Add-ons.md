# 5. Advanced Features and Add-ons

## ğŸ¯ Learning Objectives
- [ ] Master minikube's extensive addon ecosystem
- [ ] Implement monitoring and observability solutions
- [ ] Configure storage and persistence mechanisms
- [ ] Set up CI/CD integration and development workflows
- [ ] Utilize advanced cluster features and optimizations

## ğŸ“‹ Prerequisites
- Minikube cluster with sufficient resources (4+ CPU, 8GB+ RAM)
- Understanding of Kubernetes concepts and minikube basics
- kubectl configured and functional
- Docker or container runtime knowledge

## ğŸ”Œ Step 1: Comprehensive Addon Management

### Explore Available Addons
```bash
# Create addon exploration script
cat << 'EOF' > explore-addons.sh
#!/bin/bash

echo "ğŸ”Œ Minikube Addons Exploration"
echo "=============================="

# List all available addons with descriptions
echo "ğŸ“‹ Available Addons:"
minikube addons list

echo ""
echo "âœ… Currently Enabled Addons:"
minikube addons list | grep enabled

echo ""
echo "ğŸ” Addon Categories:"
echo ""

# Core Infrastructure
echo "ğŸ—ï¸  Core Infrastructure:"
echo "   â€¢ dashboard - Kubernetes Dashboard UI"
echo "   â€¢ metrics-server - Resource metrics collection"
echo "   â€¢ default-storageclass - Default storage provisioning"
echo "   â€¢ storage-provisioner - Dynamic volume provisioning"

echo ""
# Networking
echo "ğŸŒ Networking:"
echo "   â€¢ ingress - NGINX Ingress Controller"
echo "   â€¢ ingress-dns - DNS for ingress"
echo "   â€¢ istio - Service mesh platform"
echo "   â€¢ ambassador - API Gateway"

echo ""
# Development Tools
echo "ğŸ› ï¸  Development Tools:"
echo "   â€¢ registry - Local Docker registry"
echo "   â€¢ helm-tiller - Helm package manager"
echo "   â€¢ efk - Elasticsearch, Fluentd, Kibana logging"

echo ""
# Monitoring & Observability
echo "ğŸ“Š Monitoring & Observability:"
echo "   â€¢ prometheus - Metrics collection and alerting"
echo "   â€¢ grafana - Metrics visualization"
echo "   â€¢ jaeger - Distributed tracing"

echo ""
# Cloud Integration
echo "â˜ï¸  Cloud Integration:"
echo "   â€¢ gcp-auth - Google Cloud authentication"
echo "   â€¢ aws-load-balancer-controller - AWS Load Balancer"
echo "   â€¢ csi-hostpath-driver - Container Storage Interface"

echo ""
# Security
echo "ğŸ”’ Security:"
echo "   â€¢ pod-security-policy - Pod security policies"
echo "   â€¢ rbac - Role-based access control"
EOF

chmod +x explore-addons.sh
./explore-addons.sh
```

### Essential Addons Setup
```bash
# Create essential addons setup script
cat << 'EOF' > setup-essential-addons.sh
#!/bin/bash

echo "ğŸš€ Setting up Essential Addons"
echo "=============================="

# Enable core addons
echo "ğŸ—ï¸  Enabling core infrastructure addons..."
minikube addons enable dashboard
minikube addons enable metrics-server
minikube addons enable default-storageclass
minikube addons enable storage-provisioner

# Enable networking addons
echo "ğŸŒ Enabling networking addons..."
minikube addons enable ingress

# Enable development tools
echo "ğŸ› ï¸  Enabling development tools..."
minikube addons enable registry

# Wait for all addons to be ready
echo "â³ Waiting for addons to be ready..."

# Wait for dashboard
kubectl wait --namespace kubernetes-dashboard \
  --for=condition=ready pod \
  --selector=k8s-app=kubernetes-dashboard \
  --timeout=300s

# Wait for ingress
kubectl wait --namespace ingress-nginx \
  --for=condition=ready pod \
  --selector=app.kubernetes.io/component=controller \
  --timeout=300s

# Wait for metrics server
kubectl wait --namespace kube-system \
  --for=condition=ready pod \
  --selector=k8s-app=metrics-server \
  --timeout=300s

# Verify addon status
echo ""
echo "âœ… Addon Status:"
minikube addons list | grep enabled

echo ""
echo "ğŸŒ Access Information:"
echo "Dashboard: minikube dashboard"
echo "Registry: $(minikube service registry --url -n kube-system)"
echo "Ingress IP: $(minikube ip)"

echo ""
echo "ğŸ”§ Quick Commands:"
echo "Open dashboard: minikube dashboard"
echo "Check metrics: kubectl top nodes"
echo "List storage classes: kubectl get storageclass"
EOF

chmod +x setup-essential-addons.sh
./setup-essential-addons.sh
```

## ğŸ“Š Step 2: Monitoring and Observability Stack

### Prometheus and Grafana Setup
```bash
# Set up comprehensive monitoring stack
cat << 'EOF' > setup-monitoring-stack.sh
#!/bin/bash

echo "ğŸ“Š Setting up Monitoring Stack (Prometheus + Grafana)"
echo "================================================="

# Create monitoring namespace
kubectl create namespace monitoring

# Deploy Prometheus
cat << 'PROMETHEUS_EOF' | kubectl apply -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
  namespace: monitoring
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
    rule_files:
      - "/etc/prometheus/rules/*.yml"
    scrape_configs:
    - job_name: 'kubernetes-apiservers'
      kubernetes_sd_configs:
      - role: endpoints
      scheme: https
      tls_config:
        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
      relabel_configs:
      - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]
        action: keep
        regex: default;kubernetes;https
    - job_name: 'kubernetes-nodes'
      kubernetes_sd_configs:
      - role: node
      scheme: https
      tls_config:
        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
      relabel_configs:
      - action: labelmap
        regex: __meta_kubernetes_node_label_(.+)
    - job_name: 'kubernetes-pods'
      kubernetes_sd_configs:
      - role: pod
      relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
        action: replace
        target_label: __metrics_path__
        regex: (.+)
      - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
        action: replace
        regex: ([^:]+)(?::\d+)?;(\d+)
        replacement: $1:$2
        target_label: __address__
      - action: labelmap
        regex: __meta_kubernetes_pod_label_(.+)
      - source_labels: [__meta_kubernetes_namespace]
        action: replace
        target_label: kubernetes_namespace
      - source_labels: [__meta_kubernetes_pod_name]
        action: replace
        target_label: kubernetes_pod_name
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus
  namespace: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      serviceAccountName: prometheus
      containers:
      - name: prometheus
        image: prom/prometheus:v2.40.0
        args:
          - '--config.file=/etc/prometheus/prometheus.yml'
          - '--storage.tsdb.path=/prometheus/'
          - '--web.console.libraries=/etc/prometheus/console_libraries'
          - '--web.console.templates=/etc/prometheus/consoles'
          - '--web.enable-lifecycle'
          - '--storage.tsdb.retention.time=7d'
        ports:
        - containerPort: 9090
        resources:
          limits:
            cpu: 1000m
            memory: 2Gi
          requests:
            cpu: 500m
            memory: 1Gi
        volumeMounts:
        - name: prometheus-config-volume
          mountPath: /etc/prometheus/
        - name: prometheus-storage-volume
          mountPath: /prometheus/
      volumes:
      - name: prometheus-config-volume
        configMap:
          defaultMode: 420
          name: prometheus-config
      - name: prometheus-storage-volume
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: prometheus
  namespace: monitoring
spec:
  selector:
    app: prometheus
  ports:
  - port: 9090
    targetPort: 9090
  type: NodePort
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: prometheus
  namespace: monitoring
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: prometheus
rules:
- apiGroups: [""]
  resources:
  - nodes
  - nodes/proxy
  - services
  - endpoints
  - pods
  verbs: ["get", "list", "watch"]
- apiGroups:
  - extensions
  resources:
  - ingresses
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: prometheus
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: prometheus
subjects:
- kind: ServiceAccount
  name: prometheus
  namespace: monitoring
PROMETHEUS_EOF

# Deploy Grafana
cat << 'GRAFANA_EOF' | kubectl apply -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: grafana-datasources
  namespace: monitoring
data:
  prometheus.yaml: |-
    {
        "apiVersion": 1,
        "datasources": [
            {
               "access":"proxy",
                "editable": true,
                "name": "prometheus",
                "orgId": 1,
                "type": "prometheus",
                "url": "http://prometheus:9090",
                "version": 1
            }
        ]
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana
  namespace: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: grafana
  template:
    metadata:
      labels:
        app: grafana
    spec:
      securityContext:
        fsGroup: 472
        runAsUser: 472
      containers:
      - name: grafana
        image: grafana/grafana:9.3.0
        ports:
        - containerPort: 3000
        env:
        - name: GF_SECURITY_ADMIN_USER
          value: "admin"
        - name: GF_SECURITY_ADMIN_PASSWORD
          value: "admin"
        - name: GF_USERS_ALLOW_SIGN_UP
          value: "false"
        resources:
          limits:
            memory: "2Gi"
            cpu: "1000m"
          requests:
            memory: 1Gi
            cpu: "500m"
        volumeMounts:
        - mountPath: /var/lib/grafana
          name: grafana-storage
        - mountPath: /etc/grafana/provisioning/datasources
          name: grafana-datasources
          readOnly: false
      volumes:
      - name: grafana-storage
        emptyDir: {}
      - name: grafana-datasources
        configMap:
          defaultMode: 420
          name: grafana-datasources
---
apiVersion: v1
kind: Service
metadata:
  name: grafana
  namespace: monitoring
spec:
  selector:
    app: grafana
  ports:
  - port: 3000
    targetPort: 3000
  type: NodePort
GRAFANA_EOF

# Wait for deployments
echo "â³ Waiting for monitoring stack to be ready..."
kubectl wait --namespace monitoring \
  --for=condition=available \
  --timeout=300s \
  deployment/prometheus deployment/grafana

echo "âœ… Monitoring stack deployed successfully!"
echo ""
echo "ğŸŒ Access Information:"
echo "Prometheus: $(minikube service prometheus --url -n monitoring)"
echo "Grafana: $(minikube service grafana --url -n monitoring)"
echo "Grafana login: admin/admin"

# Create sample dashboard
echo ""
echo "ğŸ“Š Creating sample Kubernetes dashboard..."
kubectl exec -n monitoring deployment/grafana -- grafana-cli plugins install grafana-kubernetes-app

echo "âœ… Monitoring setup complete!"
EOF

chmod +x setup-monitoring-stack.sh
./setup-monitoring-stack.sh
```

### Logging Stack (EFK)
```bash
# Set up Elasticsearch, Fluentd, Kibana logging stack
cat << 'EOF' > setup-logging-stack.sh
#!/bin/bash

echo "ğŸ“‹ Setting up Logging Stack (EFK)"
echo "================================"

# Create logging namespace
kubectl create namespace logging

# Deploy Elasticsearch
cat << 'ELASTICSEARCH_EOF' | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: elasticsearch
  namespace: logging
spec:
  replicas: 1
  selector:
    matchLabels:
      app: elasticsearch
  template:
    metadata:
      labels:
        app: elasticsearch
    spec:
      containers:
      - name: elasticsearch
        image: docker.elastic.co/elasticsearch/elasticsearch:7.15.0
        ports:
        - containerPort: 9200
        - containerPort: 9300
        env:
        - name: discovery.type
          value: single-node
        - name: ES_JAVA_OPTS
          value: "-Xms512m -Xmx512m"
        resources:
          limits:
            memory: "1Gi"
            cpu: "1000m"
          requests:
            memory: "512Mi"
            cpu: "500m"
        volumeMounts:
        - name: elasticsearch-storage
          mountPath: /usr/share/elasticsearch/data
      volumes:
      - name: elasticsearch-storage
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: elasticsearch
  namespace: logging
spec:
  selector:
    app: elasticsearch
  ports:
  - port: 9200
    targetPort: 9200
ELASTICSEARCH_EOF

# Deploy Fluentd
cat << 'FLUENTD_EOF' | kubectl apply -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluentd-config
  namespace: logging
data:
  fluent.conf: |
    <source>
      @type tail
      path /var/log/containers/*.log
      pos_file /var/log/fluentd-containers.log.pos
      tag kubernetes.*
      read_from_head true
      <parse>
        @type json
        time_format %Y-%m-%dT%H:%M:%S.%NZ
      </parse>
    </source>

    <filter kubernetes.**>
      @type kubernetes_metadata
    </filter>

    <match **>
      @type elasticsearch
      host elasticsearch
      port 9200
      logstash_format true
      logstash_prefix kubernetes
    </match>
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd
  namespace: logging
spec:
  selector:
    matchLabels:
      name: fluentd
  template:
    metadata:
      labels:
        name: fluentd
    spec:
      serviceAccount: fluentd
      tolerations:
      - key: node-role.kubernetes.io/master
        effect: NoSchedule
      containers:
      - name: fluentd
        image: fluent/fluentd-kubernetes-daemonset:v1-debian-elasticsearch
        env:
        - name: FLUENT_ELASTICSEARCH_HOST
          value: "elasticsearch"
        - name: FLUENT_ELASTICSEARCH_PORT
          value: "9200"
        resources:
          limits:
            memory: 200Mi
          requests:
            cpu: 100m
            memory: 200Mi
        volumeMounts:
        - name: varlog
          mountPath: /var/log
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
        - name: fluentd-config
          mountPath: /fluentd/etc
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
      - name: fluentd-config
        configMap:
          name: fluentd-config
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: fluentd
  namespace: logging
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: fluentd
rules:
- apiGroups:
  - ""
  resources:
  - pods
  - namespaces
  verbs:
  - get
  - list
  - watch
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: fluentd
roleRef:
  kind: ClusterRole
  name: fluentd
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: ServiceAccount
  name: fluentd
  namespace: logging
FLUENTD_EOF

# Deploy Kibana
cat << 'KIBANA_EOF' | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kibana
  namespace: logging
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kibana
  template:
    metadata:
      labels:
        app: kibana
    spec:
      containers:
      - name: kibana
        image: docker.elastic.co/kibana/kibana:7.15.0
        ports:
        - containerPort: 5601
        env:
        - name: ELASTICSEARCH_HOSTS
          value: "http://elasticsearch:9200"
        resources:
          limits:
            memory: "1Gi"
            cpu: "1000m"
          requests:
            memory: "512Mi"
            cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: kibana
  namespace: logging
spec:
  selector:
    app: kibana
  ports:
  - port: 5601
    targetPort: 5601
  type: NodePort
KIBANA_EOF

# Wait for deployments
echo "â³ Waiting for logging stack to be ready..."
kubectl wait --namespace logging \
  --for=condition=available \
  --timeout=300s \
  deployment/elasticsearch deployment/kibana

echo "âœ… Logging stack deployed successfully!"
echo ""
echo "ğŸŒ Access Information:"
echo "Elasticsearch: $(minikube service elasticsearch --url -n logging)"
echo "Kibana: $(minikube service kibana --url -n logging)"
echo ""
echo "ğŸ” To view logs in Kibana:"
echo "1. Open Kibana URL"
echo "2. Create index pattern: kubernetes-*"
echo "3. Use @timestamp as time field"
EOF

chmod +x setup-logging-stack.sh
```

## ğŸ’¾ Step 3: Storage and Persistence

### Dynamic Storage Configuration
```bash
# Set up advanced storage configurations
cat << 'EOF' > setup-advanced-storage.sh
#!/bin/bash

echo "ğŸ’¾ Setting up Advanced Storage Configurations"
echo "============================================="

# Enable storage addons
minikube addons enable default-storageclass
minikube addons enable storage-provisioner
minikube addons enable csi-hostpath-driver

# Create custom storage classes
cat << 'STORAGE_EOF' | kubectl apply -f -
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast-ssd
  annotations:
    storageclass.kubernetes.io/is-default-class: "false"
provisioner: k8s.io/minikube-hostpath
parameters:
  type: pd-ssd
volumeBindingMode: Immediate
allowVolumeExpansion: true
reclaimPolicy: Delete
---
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: slow-hdd
  annotations:
    storageclass.kubernetes.io/is-default-class: "false"
provisioner: k8s.io/minikube-hostpath
parameters:
  type: pd-standard
volumeBindingMode: WaitForFirstConsumer
allowVolumeExpansion: true
reclaimPolicy: Retain
---
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-storage
  annotations:
    storageclass.kubernetes.io/is-default-class: "false"
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
reclaimPolicy: Delete
STORAGE_EOF

# Create test persistent volumes
cat << 'PV_EOF' | kubectl apply -f -
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-pv-1
  labels:
    type: local
spec:
  storageClassName: local-storage
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/mnt/data1"
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-pv-2
  labels:
    type: local
spec:
  storageClassName: local-storage
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteMany
  hostPath:
    path: "/mnt/data2"
PV_EOF

# Create storage demo namespace
kubectl create namespace storage-demo

# Deploy applications with different storage types
cat << 'STORAGE_DEMO_EOF' | kubectl apply -f -
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: fast-storage-claim
  namespace: storage-demo
spec:
  storageClassName: fast-ssd
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: slow-storage-claim
  namespace: storage-demo
spec:
  storageClassName: slow-hdd
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 2Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: storage-demo-app
  namespace: storage-demo
spec:
  replicas: 1
  selector:
    matchLabels:
      app: storage-demo
  template:
    metadata:
      labels:
        app: storage-demo
    spec:
      containers:
      - name: app
        image: nginx:alpine
        ports:
        - containerPort: 80
        volumeMounts:
        - name: fast-storage
          mountPath: /fast-data
        - name: slow-storage
          mountPath: /slow-data
        - name: html-content
          mountPath: /usr/share/nginx/html
      volumes:
      - name: fast-storage
        persistentVolumeClaim:
          claimName: fast-storage-claim
      - name: slow-storage
        persistentVolumeClaim:
          claimName: slow-storage-claim
      - name: html-content
        configMap:
          name: storage-demo-html
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: storage-demo-html
  namespace: storage-demo
data:
  index.html: |
    <html>
    <head><title>Storage Demo</title></head>
    <body style="font-family: Arial; padding: 20px;">
        <h1>ğŸ’¾ Storage Configuration Demo</h1>
        <h2>Available Storage Types:</h2>
        <ul>
            <li><strong>Fast SSD:</strong> /fast-data</li>
            <li><strong>Slow HDD:</strong> /slow-data</li>
        </ul>
        <script>
            // Check storage mounts via API calls if needed
            console.log("Storage demo loaded");
        </script>
    </body>
    </html>
---
apiVersion: v1
kind: Service
metadata:
  name: storage-demo-service
  namespace: storage-demo
spec:
  selector:
    app: storage-demo
  ports:
  - port: 80
    targetPort: 80
  type: NodePort
STORAGE_DEMO_EOF

# Wait for deployment
kubectl wait --namespace storage-demo \
  --for=condition=available \
  --timeout=300s \
  deployment/storage-demo-app

echo "âœ… Advanced storage configurations deployed!"
echo ""
echo "ğŸ“Š Storage Information:"
kubectl get storageclass
echo ""
kubectl get pv
echo ""
kubectl get pvc -n storage-demo
echo ""
echo "ğŸŒ Access demo: $(minikube service storage-demo-service --url -n storage-demo)"
EOF

chmod +x setup-advanced-storage.sh
./setup-advanced-storage.sh
```

## ğŸ”§ Step 4: Development Tools Integration

### Local Registry and Image Management
```bash
# Set up local registry with advanced features
cat << 'EOF' > setup-local-registry.sh
#!/bin/bash

echo "ğŸ³ Setting up Advanced Local Registry"
echo "====================================="

# Enable registry addon
minikube addons enable registry

# Deploy registry UI
cat << 'REGISTRY_UI_EOF' | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: registry-ui
  namespace: kube-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: registry-ui
  template:
    metadata:
      labels:
        app: registry-ui
    spec:
      containers:
      - name: registry-ui
        image: joxit/docker-registry-ui:static
        ports:
        - containerPort: 80
        env:
        - name: REGISTRY_TITLE
          value: "Minikube Local Registry"
        - name: REGISTRY_URL
          value: "http://registry.kube-system:80"
        - name: DELETE_IMAGES
          value: "true"
        - name: SHOW_CONTENT_DIGEST
          value: "true"
        - name: NGINX_PROXY_PASS_URL
          value: "http://registry.kube-system:80"
        - name: SHOW_CATALOG_NB_TAGS
          value: "true"
        - name: CATALOG_MIN_BRANCHES
          value: "1"
        - name: CATALOG_MAX_BRANCHES
          value: "1"
        - name: TAGLIST_PAGE_SIZE
          value: "100"
        - name: REGISTRY_SECURED
          value: "false"
        - name: CATALOG_ELEMENTS_LIMIT
          value: "1000"
---
apiVersion: v1
kind: Service
metadata:
  name: registry-ui
  namespace: kube-system
spec:
  selector:
    app: registry-ui
  ports:
  - port: 80
    targetPort: 80
  type: NodePort
REGISTRY_UI_EOF

# Create registry helper script
cat << 'REGISTRY_HELPER_EOF' > registry-helper.sh
#!/bin/bash

# Get registry information
REGISTRY_URL=$(minikube service registry --url -n kube-system)
REGISTRY_UI_URL=$(minikube service registry-ui --url -n kube-system)

echo "ğŸ³ Local Registry Helper"
echo "======================="
echo "Registry URL: $REGISTRY_URL"
echo "Registry UI: $REGISTRY_UI_URL"
echo ""

# Function to build and push to local registry
build_and_push() {
    local image_name=$1
    local tag=${2:-latest}
    
    if [ -z "$image_name" ]; then
        echo "Usage: build_and_push <image_name> [tag]"
        return 1
    fi
    
    echo "ğŸ”¨ Building image: $image_name:$tag"
    
    # Configure docker to use minikube's docker daemon
    eval $(minikube docker-env)
    
    # Build image
    docker build -t $image_name:$tag .
    
    # Tag for local registry
    local registry_host=$(echo $REGISTRY_URL | cut -d'/' -f3)
    docker tag $image_name:$tag $registry_host/$image_name:$tag
    
    # Push to registry
    echo "ğŸ“¤ Pushing to local registry..."
    docker push $registry_host/$image_name:$tag
    
    echo "âœ… Image pushed successfully!"
    echo "Use in Kubernetes: $registry_host/$image_name:$tag"
    
    # Reset docker environment
    eval $(minikube docker-env -u)
}

# Function to list images in registry
list_images() {
    echo "ğŸ“‹ Images in local registry:"
    curl -s ${REGISTRY_URL}/v2/_catalog | jq -r '.repositories[]' 2>/dev/null || echo "No images found or jq not available"
}

# Function to delete image from registry
delete_image() {
    local image_name=$1
    local tag=${2:-latest}
    
    if [ -z "$image_name" ]; then
        echo "Usage: delete_image <image_name> [tag]"
        return 1
    fi
    
    echo "ğŸ—‘ï¸ Deleting $image_name:$tag from registry..."
    # Note: Registry deletion requires additional configuration in production
    echo "âš ï¸ Image deletion requires registry configuration with DELETE enabled"
}

# Export functions
export -f build_and_push list_images delete_image

case "${1:-help}" in
    "build")
        build_and_push "$2" "$3"
        ;;
    "list")
        list_images
        ;;
    "delete")
        delete_image "$2" "$3"
        ;;
    "info")
        echo "Registry URL: $REGISTRY_URL"
        echo "Registry UI: $REGISTRY_UI_URL"
        ;;
    *)
        echo "Usage: $0 {build|list|delete|info}"
        echo ""
        echo "Commands:"
        echo "  build <name> [tag]  - Build and push image to local registry"
        echo "  list                - List images in registry"
        echo "  delete <name> [tag] - Delete image from registry"
        echo "  info                - Show registry URLs"
        echo ""
        echo "Functions available after sourcing:"
        echo "  source $0"
        echo "  build_and_push <name> [tag]"
        echo "  list_images"
        echo "  delete_image <name> [tag]"
        ;;
esac
REGISTRY_HELPER_EOF

chmod +x registry-helper.sh

# Wait for registry UI
kubectl wait --namespace kube-system \
  --for=condition=available \
  --timeout=300s \
  deployment/registry-ui

echo "âœ… Local registry with UI deployed!"
echo ""
echo "ğŸŒ Access Information:"
echo "Registry: $(minikube service registry --url -n kube-system)"
echo "Registry UI: $(minikube service registry-ui --url -n kube-system)"
echo ""
echo "ğŸ› ï¸ Helper script: ./registry-helper.sh"
echo "Usage examples:"
echo "  ./registry-helper.sh info"
echo "  ./registry-helper.sh list"
echo "  source ./registry-helper.sh && build_and_push myapp latest"
EOF

chmod +x setup-local-registry.sh
./setup-local-registry.sh
```

### CI/CD Integration with Tekton
```bash
# Set up Tekton Pipelines for CI/CD
cat << 'EOF' > setup-tekton-pipelines.sh
#!/bin/bash

echo "ğŸ”„ Setting up Tekton Pipelines"
echo "=============================="

# Install Tekton Pipelines
kubectl apply --filename https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml

# Wait for Tekton to be ready
echo "â³ Waiting for Tekton components to be ready..."
kubectl wait --namespace tekton-pipelines \
  --for=condition=ready pod \
  --selector=app=tekton-pipelines-controller \
  --timeout=300s

# Install Tekton Dashboard
kubectl apply --filename https://storage.googleapis.com/tekton-releases/dashboard/latest/tekton-dashboard-release.yaml

# Wait for dashboard
kubectl wait --namespace tekton-pipelines \
  --for=condition=ready pod \
  --selector=app=tekton-dashboard \
  --timeout=300s

# Create demo namespace for pipelines
kubectl create namespace tekton-demo

# Create sample pipeline
cat << 'PIPELINE_EOF' | kubectl apply -f -
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: hello-world-task
  namespace: tekton-demo
spec:
  steps:
    - name: echo
      image: ubuntu
      command:
        - echo
      args:
        - "Hello World from Tekton!"
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: build-image-task
  namespace: tekton-demo
spec:
  params:
    - name: image-name
      description: Name of the image to build
  steps:
    - name: build
      image: gcr.io/kaniko-project/executor:latest
      args:
        - --dockerfile=Dockerfile
        - --destination=$(params.image-name)
        - --context=/workspace
      volumeMounts:
        - name: workspace
          mountPath: /workspace
  volumes:
    - name: workspace
      emptyDir: {}
---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: demo-pipeline
  namespace: tekton-demo
spec:
  params:
    - name: image-name
      type: string
      default: "localhost:5000/demo-app:latest"
  tasks:
    - name: hello-world
      taskRef:
        name: hello-world-task
    - name: build-image
      taskRef:
        name: build-image-task
      params:
        - name: image-name
          value: $(params.image-name)
      runAfter:
        - hello-world
---
apiVersion: tekton.dev/v1beta1
kind: PipelineRun
metadata:
  name: demo-pipeline-run
  namespace: tekton-demo
spec:
  pipelineRef:
    name: demo-pipeline
  params:
    - name: image-name
      value: "localhost:5000/tekton-demo:v1.0.0"
PIPELINE_EOF

echo "âœ… Tekton Pipelines deployed!"
echo ""
echo "ğŸŒ Access Information:"
echo "Dashboard: kubectl port-forward -n tekton-pipelines service/tekton-dashboard 9097:9097"
echo "Then open: http://localhost:9097"
echo ""
echo "ğŸ”§ Quick Commands:"
echo "List pipelines: kubectl get pipelines -n tekton-demo"
echo "List pipeline runs: kubectl get pipelineruns -n tekton-demo"
echo "Watch pipeline run: kubectl get pipelinerun demo-pipeline-run -n tekton-demo -w"
EOF

chmod +x setup-tekton-pipelines.sh
```

## ğŸ”’ Step 5: Security and RBAC

### Advanced Security Configuration
```bash
# Set up comprehensive security policies
cat << 'EOF' > setup-security-policies.sh
#!/bin/bash

echo "ğŸ”’ Setting up Security Policies"
echo "==============================="

# Create security namespace
kubectl create namespace security-demo

# Create Pod Security Policy
cat << 'PSP_EOF' | kubectl apply -f -
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted-psp
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  volumes:
    - 'configMap'
    - 'emptyDir'
    - 'projected'
    - 'secret'
    - 'downwardAPI'
    - 'persistentVolumeClaim'
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'RunAsAny'
  fsGroup:
    rule: 'RunAsAny'
  readOnlyRootFilesystem: false
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: restricted-psp-user
  namespace: security-demo
rules:
- apiGroups: ['policy']
  resources: ['podsecuritypolicies']
  verbs: ['use']
  resourceNames:
  - restricted-psp
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: restricted-psp-user
  namespace: security-demo
roleRef:
  kind: Role
  name: restricted-psp-user
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: ServiceAccount
  name: default
  namespace: security-demo
PSP_EOF

# Create Network Policies
cat << 'NETPOL_EOF' | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: security-demo
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: security-demo
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend
    ports:
    - protocol: TCP
      port: 8080
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns
  namespace: security-demo
spec:
  podSelector: {}
  policyTypes:
  - Egress
  egress:
  - to: []
    ports:
    - protocol: UDP
      port: 53
    - protocol: TCP
      port: 53
NETPOL_EOF

# Create RBAC example
cat << 'RBAC_EOF' | kubectl apply -f -
apiVersion: v1
kind: ServiceAccount
metadata:
  name: developer
  namespace: security-demo
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: security-demo
  name: developer-role
rules:
- apiGroups: [""]
  resources: ["pods", "services", "configmaps"]
  verbs: ["get", "list", "create", "update", "patch", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets"]
  verbs: ["get", "list", "create", "update", "patch", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: developer-binding
  namespace: security-demo
subjects:
- kind: ServiceAccount
  name: developer
  namespace: security-demo
roleRef:
  kind: Role
  name: developer-role
  apiGroup: rbac.authorization.k8s.io
RBAC_EOF

# Deploy secure application example
cat << 'SECURE_APP_EOF' | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: secure-frontend
  namespace: security-demo
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      serviceAccountName: developer
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 2000
      containers:
      - name: nginx
        image: nginx:alpine
        ports:
        - containerPort: 80
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1000
          capabilities:
            drop:
              - ALL
        resources:
          limits:
            cpu: 500m
            memory: 512Mi
          requests:
            cpu: 250m
            memory: 256Mi
        volumeMounts:
        - name: nginx-cache
          mountPath: /var/cache/nginx
        - name: nginx-pid
          mountPath: /var/run
      volumes:
      - name: nginx-cache
        emptyDir: {}
      - name: nginx-pid
        emptyDir: {}
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: secure-backend
  namespace: security-demo
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      serviceAccountName: developer
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        fsGroup: 2001
      containers:
      - name: app
        image: nginx:alpine
        ports:
        - containerPort: 8080
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1001
          capabilities:
            drop:
              - ALL
        resources:
          limits:
            cpu: 500m
            memory: 512Mi
          requests:
            cpu: 250m
            memory: 256Mi
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
  namespace: security-demo
spec:
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: security-demo
spec:
  selector:
    app: backend
  ports:
  - port: 8080
    targetPort: 8080
SECURE_APP_EOF

# Wait for deployments
kubectl wait --namespace security-demo \
  --for=condition=available \
  --timeout=300s \
  deployment/secure-frontend deployment/secure-backend

echo "âœ… Security policies and secure applications deployed!"
echo ""
echo "ğŸ”’ Security Features Enabled:"
echo "  â€¢ Pod Security Policies"
echo "  â€¢ Network Policies (default deny)"
echo "  â€¢ RBAC with limited permissions"
echo "  â€¢ Security contexts with non-root users"
echo "  â€¢ Resource limits and requests"
echo "  â€¢ Read-only root filesystem"
echo ""
echo "ğŸ” Test Security:"
echo "kubectl auth can-i create pods --as=system:serviceaccount:security-demo:developer -n security-demo"
echo "kubectl get pods -n security-demo"
echo "kubectl get networkpolicies -n security-demo"
EOF

chmod +x setup-security-policies.sh
./setup-security-policies.sh
```

## âœ… Success Criteria

### âœ… Advanced Features Checklist
- [ ] Master comprehensive addon management and configuration
- [ ] Deploy and configure monitoring stack (Prometheus + Grafana)
- [ ] Set up centralized logging (EFK stack)
- [ ] Implement advanced storage configurations
- [ ] Configure local registry with UI and helper tools
- [ ] Deploy CI/CD pipelines with Tekton
- [ ] Implement comprehensive security policies
- [ ] Understand performance tuning and resource optimization

### âœ… Validation Commands
```bash
# Test all advanced features:
./explore-addons.sh
./setup-monitoring-stack.sh
./setup-advanced-storage.sh
./setup-local-registry.sh
./setup-security-policies.sh

# Access monitoring
minikube service prometheus -n monitoring
minikube service grafana -n monitoring

# Test registry
./registry-helper.sh info

# Check security
kubectl get psp,networkpolicies,roles,rolebindings -n security-demo
```

## ğŸ¯ Next Steps

After mastering advanced features:

1. **Performance Optimization** - Resource tuning and cluster optimization
2. **Production Readiness** - Transition strategies to production clusters
3. **GitOps Workflows** - Advanced deployment automation
4. **Service Mesh Mastery** - Deep dive into Istio/Linkerd
5. **Cloud Integration** - Hybrid cloud and multi-cluster scenarios

## ğŸ“š Key Takeaways

### What You've Learned
1. **Addon Ecosystem**: Comprehensive understanding of minikube's extension capabilities
2. **Observability**: Complete monitoring, logging, and tracing stack implementation
3. **Storage Management**: Advanced persistent storage configurations and patterns
4. **Development Workflow**: Local registry, CI/CD pipelines, and development tooling
5. **Security Implementation**: Pod security policies, RBAC, and network isolation

### Best Practices Implemented
- Comprehensive monitoring and observability setup
- Secure-by-default application deployments
- Automated CI/CD pipeline integration
- Advanced storage management with multiple storage classes
- Multi-tenant security and network isolation

These advanced features enable production-like development environments with enterprise-grade capabilities for testing, monitoring, and security validation.