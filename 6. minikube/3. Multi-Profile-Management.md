# 3. Multi-Profile Management

## üéØ Learning Objectives
- [ ] Create and manage multiple minikube profiles
- [ ] Understand profile isolation and use cases
- [ ] Implement environment-specific configurations
- [ ] Master profile switching and context management
- [ ] Automate multi-environment workflows

## üìã Prerequisites
- Minikube installed and working
- Understanding of basic minikube commands
- kubectl configured and functional
- Sufficient system resources for multiple clusters

## üèóÔ∏è Step 1: Profile Concepts and Planning

### Understanding Profiles
```bash
# A profile represents an isolated minikube cluster
# Each profile has its own:
# - Virtual machine/container
# - Kubernetes cluster
# - kubectl context
# - Configuration settings
# - Addons and resources

# Profile naming conventions (examples)
# - development, dev, local-dev
# - staging, stage, pre-prod
# - testing, test, qa
# - production, prod (for local production-like testing)
# - feature-branch-name
# - version-specific (k8s-1.28, k8s-1.29)
```

### Profile Planning Matrix
```bash
# Create profile planning document
cat << 'EOF' > profile-planning.md
# Minikube Profile Planning

| Profile | Purpose | Resources | Addons | Kubernetes Version |
|---------|---------|-----------|--------|--------------------|
| development | Daily development | 4 CPU, 8GB RAM, 40GB | ingress, dashboard, metrics-server, registry | Latest |
| staging | Pre-production testing | 3 CPU, 6GB RAM, 30GB | ingress, metrics-server | Production version |
| testing | Automated testing | 2 CPU, 4GB RAM, 20GB | metrics-server | Production version |
| performance | Performance testing | 6 CPU, 12GB RAM, 50GB | metrics-server, istio | Production version |
| feature-x | Feature development | 2 CPU, 4GB RAM, 20GB | ingress, dashboard | Latest |

## Profile-Specific Use Cases

### Development Profile
- Hot-reload development
- Full addon suite for debugging
- Local registry for image builds
- Maximum resource allocation

### Staging Profile  
- Production-like configuration
- Minimal addons (production parity)
- Integration testing
- Moderate resource allocation

### Testing Profile
- Automated test execution
- Minimal resource footprint
- Quick startup/teardown
- CI/CD integration

### Performance Profile
- Load testing
- Resource monitoring
- Service mesh testing
- Maximum resource allocation
EOF
```

## üöÄ Step 2: Creating and Configuring Profiles

### Development Profile Setup
```bash
# Create comprehensive development profile setup
cat << 'EOF' > setup-development-profile.sh
#!/bin/bash

PROFILE_NAME="development"

echo "üîß Setting up $PROFILE_NAME profile"
echo "======================================"

# Start development profile with rich configuration
minikube start -p $PROFILE_NAME \
  --cpus=4 \
  --memory=8192 \
  --disk-size=40g \
  --driver=docker \
  --kubernetes-version=v1.28.0 \
  --container-runtime=containerd \
  --feature-gates="EphemeralContainers=true" \
  --extra-config=apiserver.enable-admission-plugins="NamespaceLifecycle,ResourceQuota,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds"

# Wait for cluster to be ready
echo "‚è≥ Waiting for cluster to be ready..."
minikube kubectl -- wait --for=condition=Ready nodes --all --timeout=300s -p $PROFILE_NAME

# Enable development-focused addons
echo "üîå Enabling addons..."
minikube addons enable dashboard -p $PROFILE_NAME
minikube addons enable ingress -p $PROFILE_NAME
minikube addons enable metrics-server -p $PROFILE_NAME
minikube addons enable registry -p $PROFILE_NAME
minikube addons enable storage-provisioner -p $PROFILE_NAME
minikube addons enable default-storageclass -p $PROFILE_NAME

# Create development namespaces
echo "üì¶ Creating development namespaces..."
minikube kubectl -- create namespace dev-frontend -p $PROFILE_NAME
minikube kubectl -- create namespace dev-backend -p $PROFILE_NAME
minikube kubectl -- create namespace dev-database -p $PROFILE_NAME
minikube kubectl -- create namespace monitoring -p $PROFILE_NAME

# Apply resource quotas for development
cat << 'QUOTA_EOF' | minikube kubectl -- apply -f - -p $PROFILE_NAME
apiVersion: v1
kind: ResourceQuota
metadata:
  name: dev-quota
  namespace: dev-frontend
spec:
  hard:
    requests.cpu: "2"
    requests.memory: 4Gi
    limits.cpu: "4"
    limits.memory: 8Gi
    pods: "10"
---
apiVersion: v1
kind: ResourceQuota
metadata:
  name: dev-quota
  namespace: dev-backend
spec:
  hard:
    requests.cpu: "2"
    requests.memory: 4Gi
    limits.cpu: "4"
    limits.memory: 8Gi
    pods: "10"
QUOTA_EOF

# Configure docker environment for development
echo "üê≥ Configuring Docker environment..."
echo "# Add to your shell profile:"
echo "alias docker-dev='eval \$(minikube docker-env -p $PROFILE_NAME)'"
echo "alias kubectl-dev='kubectl --context=$PROFILE_NAME'"

# Display access information
echo "‚úÖ Development profile setup complete!"
echo ""
echo "üìä Profile Information:"
minikube profile list
echo ""
echo "üåê Access URLs:"
echo "Dashboard: $(minikube dashboard --url -p $PROFILE_NAME)"
echo "Registry: $(minikube service registry --url -n kube-system -p $PROFILE_NAME)"
echo ""
echo "üîß Quick commands:"
echo "Switch context: kubectl config use-context $PROFILE_NAME"
echo "Use registry: eval \$(minikube docker-env -p $PROFILE_NAME)"
echo "Monitor: watch kubectl get pods --all-namespaces"
EOF

chmod +x setup-development-profile.sh
```

### Staging Profile Setup
```bash
# Create staging profile setup (production-like)
cat << 'EOF' > setup-staging-profile.sh
#!/bin/bash

PROFILE_NAME="staging"

echo "üé≠ Setting up $PROFILE_NAME profile"
echo "==================================="

# Start staging profile with production-like configuration
minikube start -p $PROFILE_NAME \
  --cpus=3 \
  --memory=6144 \
  --disk-size=30g \
  --driver=docker \
  --kubernetes-version=v1.27.8 \
  --container-runtime=containerd \
  --extra-config=apiserver.audit-log-maxage=30 \
  --extra-config=apiserver.audit-log-maxbackup=3 \
  --extra-config=apiserver.audit-log-maxsize=100

# Wait for cluster to be ready
echo "‚è≥ Waiting for cluster to be ready..."
minikube kubectl -- wait --for=condition=Ready nodes --all --timeout=300s -p $PROFILE_NAME

# Enable minimal production-like addons
echo "üîå Enabling production addons..."
minikube addons enable ingress -p $PROFILE_NAME
minikube addons enable metrics-server -p $PROFILE_NAME

# Create staging namespaces
echo "üì¶ Creating staging namespaces..."
minikube kubectl -- create namespace staging-app -p $PROFILE_NAME
minikube kubectl -- create namespace staging-monitoring -p $PROFILE_NAME

# Apply strict resource quotas
cat << 'QUOTA_EOF' | minikube kubectl -- apply -f - -p $PROFILE_NAME
apiVersion: v1
kind: ResourceQuota
metadata:
  name: staging-quota
  namespace: staging-app
spec:
  hard:
    requests.cpu: "1.5"
    requests.memory: 3Gi
    limits.cpu: "3"
    limits.memory: 6Gi
    pods: "5"
    services: "5"
---
apiVersion: v1
kind: LimitRange
metadata:
  name: staging-limits
  namespace: staging-app
spec:
  limits:
  - default:
      cpu: 500m
      memory: 512Mi
    defaultRequest:
      cpu: 100m
      memory: 128Mi
    type: Container
QUOTA_EOF

# Apply network policies for staging
cat << 'NETPOL_EOF' | minikube kubectl -- apply -f - -p $PROFILE_NAME
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: staging-app
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
NETPOL_EOF

echo "‚úÖ Staging profile setup complete!"
echo ""
echo "üìä Profile Information:"
minikube profile list
echo ""
echo "üîß Quick commands:"
echo "Switch context: kubectl config use-context $PROFILE_NAME"
echo "Check resources: kubectl top nodes"
EOF

chmod +x setup-staging-profile.sh
```

### Testing Profile Setup
```bash
# Create lightweight testing profile
cat << 'EOF' > setup-testing-profile.sh
#!/bin/bash

PROFILE_NAME="testing"

echo "üß™ Setting up $PROFILE_NAME profile"
echo "==================================="

# Start minimal testing profile
minikube start -p $PROFILE_NAME \
  --cpus=2 \
  --memory=4096 \
  --disk-size=20g \
  --driver=docker \
  --kubernetes-version=v1.27.8 \
  --container-runtime=containerd

# Wait for cluster to be ready
echo "‚è≥ Waiting for cluster to be ready..."
minikube kubectl -- wait --for=condition=Ready nodes --all --timeout=300s -p $PROFILE_NAME

# Enable minimal addons for testing
echo "üîå Enabling testing addons..."
minikube addons enable metrics-server -p $PROFILE_NAME

# Create testing namespace
echo "üì¶ Creating testing namespace..."
minikube kubectl -- create namespace testing -p $PROFILE_NAME

# Apply testing resource quotas (very limited)
cat << 'QUOTA_EOF' | minikube kubectl -- apply -f - -p $PROFILE_NAME
apiVersion: v1
kind: ResourceQuota
metadata:
  name: testing-quota
  namespace: testing
spec:
  hard:
    requests.cpu: "1"
    requests.memory: 2Gi
    limits.cpu: "2"
    limits.memory: 4Gi
    pods: "3"
QUOTA_EOF

echo "‚úÖ Testing profile setup complete!"
echo ""
echo "üìä Profile Information:"
minikube profile list
echo ""
echo "üîß Quick commands:"
echo "Switch context: kubectl config use-context $PROFILE_NAME"
echo "Run tests: kubectl run test --image=busybox --rm -it --restart=Never -- /bin/sh"
EOF

chmod +x setup-testing-profile.sh
```

## üîÑ Step 3: Profile Management Operations

### Profile Switching and Context Management
```bash
# Create profile switching utility
cat << 'EOF' > profile-switcher.sh
#!/bin/bash

# Display current active profiles
show_profiles() {
    echo "üìã Available Minikube Profiles:"
    echo "==============================="
    minikube profile list
    echo ""
    echo "Current kubectl context: $(kubectl config current-context)"
    echo ""
}

# Switch to specific profile
switch_profile() {
    local profile=$1
    
    if [ -z "$profile" ]; then
        echo "‚ùå Please specify a profile name"
        show_profiles
        return 1
    fi
    
    echo "üîÑ Switching to profile: $profile"
    
    # Set minikube profile
    minikube profile $profile
    
    # Switch kubectl context
    kubectl config use-context $profile
    
    echo "‚úÖ Switched to profile: $profile"
    
    # Show profile info
    echo ""
    echo "üìä Profile Status:"
    minikube status -p $profile
    
    echo ""
    echo "üåê Available Services:"
    minikube service list -p $profile
}

# Interactive profile selector
interactive_switch() {
    echo "üîÑ Interactive Profile Switcher"
    echo "==============================="
    
    # Get available profiles
    profiles=($(minikube profile list -o json | jq -r '.[].Name'))
    
    if [ ${#profiles[@]} -eq 0 ]; then
        echo "‚ùå No profiles found"
        return 1
    fi
    
    echo "Select a profile:"
    for i in "${!profiles[@]}"; do
        status=$(minikube status -p "${profiles[$i]}" --format='{{.Host}}' 2>/dev/null || echo "Unknown")
        echo "$((i+1)). ${profiles[$i]} ($status)"
    done
    
    read -p "Enter choice (1-${#profiles[@]}): " choice
    
    if [[ $choice =~ ^[0-9]+$ ]] && [ $choice -ge 1 ] && [ $choice -le ${#profiles[@]} ]; then
        selected_profile="${profiles[$((choice-1))]}"
        switch_profile "$selected_profile"
    else
        echo "‚ùå Invalid selection"
    fi
}

# Main menu
case "${1:-interactive}" in
    "list"|"show")
        show_profiles
        ;;
    "interactive"|"")
        interactive_switch
        ;;
    *)
        switch_profile "$1"
        ;;
esac
EOF

chmod +x profile-switcher.sh
```

### Bulk Profile Operations
```bash
# Create bulk operations script
cat << 'EOF' > bulk-profile-ops.sh
#!/bin/bash

# Start all profiles
start_all() {
    echo "üöÄ Starting all profiles..."
    
    profiles=($(minikube profile list -o json | jq -r '.[].Name'))
    
    for profile in "${profiles[@]}"; do
        echo "Starting profile: $profile"
        minikube start -p $profile &
    done
    
    wait
    echo "‚úÖ All profiles started"
}

# Stop all profiles
stop_all() {
    echo "üõë Stopping all profiles..."
    
    profiles=($(minikube profile list -o json | jq -r '.[].Name'))
    
    for profile in "${profiles[@]}"; do
        echo "Stopping profile: $profile"
        minikube stop -p $profile
    done
    
    echo "‚úÖ All profiles stopped"
}

# Status of all profiles
status_all() {
    echo "üìä Status of all profiles:"
    echo "=========================="
    
    profiles=($(minikube profile list -o json | jq -r '.[].Name'))
    
    for profile in "${profiles[@]}"; do
        echo ""
        echo "Profile: $profile"
        echo "----------------"
        minikube status -p $profile
    done
}

# Delete all profiles
delete_all() {
    echo "‚ö†Ô∏è  This will delete ALL minikube profiles!"
    read -p "Are you sure? (yes/no): " confirm
    
    if [ "$confirm" = "yes" ]; then
        echo "üóëÔ∏è  Deleting all profiles..."
        minikube delete --all
        echo "‚úÖ All profiles deleted"
    else
        echo "‚ùå Operation cancelled"
    fi
}

# Resource summary for all profiles
resource_summary() {
    echo "üìà Resource Summary for All Profiles:"
    echo "====================================="
    
    profiles=($(minikube profile list -o json | jq -r '.[].Name'))
    total_cpu=0
    total_memory=0
    
    for profile in "${profiles[@]}"; do
        status=$(minikube status -p $profile --format='{{.Host}}' 2>/dev/null || echo "Stopped")
        cpu=$(minikube config get cpus -p $profile 2>/dev/null || echo "2")
        memory=$(minikube config get memory -p $profile 2>/dev/null || echo "4096")
        
        echo "Profile: $profile | Status: $status | CPU: ${cpu} | Memory: ${memory}MB"
        
        if [ "$status" = "Running" ]; then
            total_cpu=$((total_cpu + cpu))
            total_memory=$((total_memory + memory))
        fi
    done
    
    echo ""
    echo "Total Resources (Running Profiles):"
    echo "CPU: ${total_cpu} cores"
    echo "Memory: ${total_memory}MB ($(echo "scale=2; $total_memory/1024" | bc)GB)"
}

# Main operations
case "$1" in
    "start-all")
        start_all
        ;;
    "stop-all")
        stop_all
        ;;
    "status-all")
        status_all
        ;;
    "delete-all")
        delete_all
        ;;
    "resources")
        resource_summary
        ;;
    *)
        echo "Usage: $0 {start-all|stop-all|status-all|delete-all|resources}"
        echo ""
        echo "Commands:"
        echo "  start-all   - Start all profiles in parallel"
        echo "  stop-all    - Stop all profiles"
        echo "  status-all  - Show status of all profiles"
        echo "  delete-all  - Delete all profiles (with confirmation)"
        echo "  resources   - Show resource summary"
        ;;
esac
EOF

chmod +x bulk-profile-ops.sh
```

## üè∑Ô∏è Step 4: Environment-Specific Configurations

### Development Environment Configuration
```bash
# Create development-specific configuration
cat << 'EOF' > config-development.sh
#!/bin/bash

PROFILE="development"

echo "‚öôÔ∏è Configuring development environment for profile: $PROFILE"

# Switch to development profile
minikube profile $PROFILE
kubectl config use-context $PROFILE

# Install development tools
echo "üîß Installing development tools..."

# Deploy development ingress with custom configuration
cat << 'INGRESS_EOF' | kubectl apply -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-configuration
  namespace: ingress-nginx
data:
  enable-cors: "true"
  cors-allow-origin: "*"
  cors-allow-methods: "GET, PUT, POST, DELETE, PATCH, OPTIONS"
  cors-allow-headers: "DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization"
INGRESS_EOF

# Deploy local development registry with UI
cat << 'REGISTRY_EOF' | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: registry-ui
  namespace: kube-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: registry-ui
  template:
    metadata:
      labels:
        app: registry-ui
    spec:
      containers:
      - name: registry-ui
        image: joxit/docker-registry-ui:static
        ports:
        - containerPort: 80
        env:
        - name: REGISTRY_TITLE
          value: "Minikube Development Registry"
        - name: REGISTRY_URL
          value: "http://registry.kube-system:80"
---
apiVersion: v1
kind: Service
metadata:
  name: registry-ui
  namespace: kube-system
spec:
  ports:
  - port: 80
    targetPort: 80
  selector:
    app: registry-ui
REGISTRY_EOF

# Create development helper scripts
cat << 'HELPERS_EOF' > dev-helpers.sh
#!/bin/bash

# Quick deployment for testing
quick_deploy() {
    local name=$1
    local image=${2:-nginx}
    local port=${3:-80}
    
    kubectl create deployment $name --image=$image
    kubectl expose deployment $name --port=$port --type=NodePort
    kubectl scale deployment $name --replicas=2
    
    echo "‚úÖ Deployed $name"
    echo "üåê Access: $(minikube service $name --url)"
}

# Quick cleanup
quick_cleanup() {
    kubectl delete deployment --all
    kubectl delete service --all
    kubectl delete ingress --all
}

# Port forward helper
port_forward() {
    local service=$1
    local port=${2:-8080}
    
    echo "üîå Port forwarding $service to localhost:$port"
    kubectl port-forward service/$service $port:80
}

export -f quick_deploy quick_cleanup port_forward
HELPERS_EOF

chmod +x dev-helpers.sh
source dev-helpers.sh

echo "‚úÖ Development environment configured"
echo ""
echo "üöÄ Available helper functions:"
echo "  quick_deploy <name> [image] [port]"
echo "  quick_cleanup"
echo "  port_forward <service> [local-port]"
echo ""
echo "üåê Access URLs:"
echo "Dashboard: $(minikube dashboard --url)"
echo "Registry: $(minikube service registry --url -n kube-system)"
echo "Registry UI: $(minikube service registry-ui --url -n kube-system)"
EOF

chmod +x config-development.sh
```

### Production-like Configuration
```bash
# Create production-like configuration for staging
cat << 'EOF' > config-production-like.sh
#!/bin/bash

PROFILE="staging"

echo "üé≠ Configuring production-like environment for profile: $PROFILE"

# Switch to staging profile
minikube profile $PROFILE
kubectl config use-context $PROFILE

# Apply production-like security policies
echo "üîí Applying security policies..."

# Pod Security Policy
cat << 'PSP_EOF' | kubectl apply -f -
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  volumes:
    - 'configMap'
    - 'emptyDir'
    - 'projected'
    - 'secret'
    - 'downwardAPI'
    - 'persistentVolumeClaim'
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'RunAsAny'
  fsGroup:
    rule: 'RunAsAny'
PSP_EOF

# Network Policies for production-like isolation
cat << 'NETPOL_EOF' | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all-ingress
  namespace: staging-app
spec:
  podSelector: {}
  policyTypes:
  - Ingress
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-ingress-controller
  namespace: staging-app
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
NETPOL_EOF

# Deploy monitoring stack
echo "üìä Deploying monitoring stack..."

# Prometheus monitoring
cat << 'MONITORING_EOF' | kubectl apply -f -
apiVersion: v1
kind: Namespace
metadata:
  name: monitoring
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus
  namespace: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      containers:
      - name: prometheus
        image: prom/prometheus:latest
        ports:
        - containerPort: 9090
        resources:
          limits:
            cpu: 500m
            memory: 1Gi
          requests:
            cpu: 100m
            memory: 512Mi
---
apiVersion: v1
kind: Service
metadata:
  name: prometheus
  namespace: monitoring
spec:
  ports:
  - port: 9090
    targetPort: 9090
  selector:
    app: prometheus
MONITORING_EOF

echo "‚úÖ Production-like environment configured"
echo ""
echo "üîí Security features enabled:"
echo "  - Pod Security Policies"
echo "  - Network Policies"
echo "  - Resource Quotas"
echo "  - Audit Logging"
echo ""
echo "üìä Monitoring stack deployed"
echo "Access Prometheus: kubectl port-forward -n monitoring service/prometheus 9090:9090"
EOF

chmod +x config-production-like.sh
```

## üîÑ Step 5: Profile Automation and CI/CD Integration

### CI/CD Profile Management
```bash
# Create CI/CD integration script
cat << 'EOF' > ci-cd-profile-manager.sh
#!/bin/bash

# Environment variables for CI/CD
BRANCH_NAME=${BRANCH_NAME:-"main"}
BUILD_NUMBER=${BUILD_NUMBER:-"local"}
PROFILE_PREFIX=${PROFILE_PREFIX:-"ci"}

# Generate profile name based on branch and build
generate_profile_name() {
    local branch=$(echo $BRANCH_NAME | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]')
    echo "${PROFILE_PREFIX}-${branch}-${BUILD_NUMBER}"
}

# Create ephemeral testing profile
create_test_profile() {
    local profile=$(generate_profile_name)
    
    echo "üß™ Creating test profile: $profile"
    
    # Start lightweight profile for testing
    minikube start -p $profile \
      --cpus=2 \
      --memory=4096 \
      --disk-size=20g \
      --driver=docker \
      --kubernetes-version=v1.27.8
    
    # Enable minimal addons
    minikube addons enable metrics-server -p $profile
    
    # Switch context
    kubectl config use-context $profile
    
    echo "‚úÖ Test profile ready: $profile"
    return 0
}

# Run tests in profile
run_tests() {
    local profile=$(generate_profile_name)
    
    echo "üß™ Running tests in profile: $profile"
    
    # Switch to test profile
    kubectl config use-context $profile
    
    # Deploy test application
    kubectl create namespace testing
    kubectl run test-app --image=nginx --port=80 -n testing
    kubectl expose pod test-app --port=80 --type=NodePort -n testing
    
    # Wait for pod to be ready
    kubectl wait --for=condition=Ready pod/test-app -n testing --timeout=120s
    
    # Run basic connectivity test
    if minikube service test-app --url -n testing; then
        echo "‚úÖ Basic connectivity test passed"
        return 0
    else
        echo "‚ùå Basic connectivity test failed"
        return 1
    fi
}

# Cleanup test profile
cleanup_test_profile() {
    local profile=$(generate_profile_name)
    
    echo "üßπ Cleaning up test profile: $profile"
    minikube delete -p $profile
    
    echo "‚úÖ Test profile cleaned up: $profile"
}

# Main CI/CD workflow
run_ci_workflow() {
    echo "üöÄ Starting CI/CD workflow"
    echo "=========================="
    echo "Branch: $BRANCH_NAME"
    echo "Build: $BUILD_NUMBER"
    
    # Create and setup test environment
    if create_test_profile; then
        echo "‚úÖ Test environment created"
    else
        echo "‚ùå Failed to create test environment"
        exit 1
    fi
    
    # Run tests
    if run_tests; then
        echo "‚úÖ Tests passed"
        test_result=0
    else
        echo "‚ùå Tests failed"
        test_result=1
    fi
    
    # Cleanup (always run)
    cleanup_test_profile
    
    # Exit with test result
    exit $test_result
}

# Command line interface
case "$1" in
    "create")
        create_test_profile
        ;;
    "test")
        run_tests
        ;;
    "cleanup")
        cleanup_test_profile
        ;;
    "workflow")
        run_ci_workflow
        ;;
    *)
        echo "Usage: $0 {create|test|cleanup|workflow}"
        echo ""
        echo "Commands:"
        echo "  create   - Create ephemeral test profile"
        echo "  test     - Run tests in current profile"
        echo "  cleanup  - Cleanup test profile"
        echo "  workflow - Run complete CI/CD workflow"
        echo ""
        echo "Environment variables:"
        echo "  BRANCH_NAME - Git branch name (default: main)"
        echo "  BUILD_NUMBER - Build number (default: local)"
        echo "  PROFILE_PREFIX - Profile name prefix (default: ci)"
        ;;
esac
EOF

chmod +x ci-cd-profile-manager.sh
```

## üìä Step 6: Monitoring and Resource Management

### Multi-Profile Resource Monitor
```bash
# Create comprehensive monitoring dashboard
cat << 'EOF' > multi-profile-monitor.sh
#!/bin/bash

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to format bytes
format_bytes() {
    local bytes=$1
    if [ $bytes -gt 1073741824 ]; then
        echo "$(echo "scale=2; $bytes/1073741824" | bc)GB"
    elif [ $bytes -gt 1048576 ]; then
        echo "$(echo "scale=2; $bytes/1048576" | bc)MB"
    else
        echo "${bytes}B"
    fi
}

# Display header
display_header() {
    clear
    echo -e "${BLUE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
    echo -e "${BLUE}‚ïë                    Minikube Multi-Profile Monitor                ‚ïë${NC}"
    echo -e "${BLUE}‚ïë                    $(date '+%Y-%m-%d %H:%M:%S')                        ‚ïë${NC}"
    echo -e "${BLUE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
    echo ""
}

# Monitor single profile
monitor_profile() {
    local profile=$1
    local status=$(minikube status -p $profile --format='{{.Host}}' 2>/dev/null || echo "Unknown")
    
    # Profile header
    if [ "$status" = "Running" ]; then
        echo -e "${GREEN}üìä Profile: $profile ($status)${NC}"
    else
        echo -e "${RED}üìä Profile: $profile ($status)${NC}"
        return
    fi
    
    # Switch context temporarily
    local current_context=$(kubectl config current-context)
    kubectl config use-context $profile &>/dev/null
    
    # Get resource information
    local node_cpu=$(kubectl top nodes --no-headers 2>/dev/null | awk '{print $2}' | head -1)
    local node_memory=$(kubectl top nodes --no-headers 2>/dev/null | awk '{print $3}' | head -1)
    local pod_count=$(kubectl get pods --all-namespaces --no-headers 2>/dev/null | wc -l)
    local running_pods=$(kubectl get pods --all-namespaces --no-headers 2>/dev/null | grep Running | wc -l)
    
    # Get configuration
    local config_cpu=$(minikube config get cpus -p $profile 2>/dev/null || echo "N/A")
    local config_memory=$(minikube config get memory -p $profile 2>/dev/null || echo "N/A")
    
    # Display information
    echo "   CPU Usage: ${node_cpu:-N/A} (Allocated: ${config_cpu} cores)"
    echo "   Memory Usage: ${node_memory:-N/A} (Allocated: ${config_memory}MB)"
    echo "   Pods: $running_pods/$pod_count running"
    
    # Get service count
    local service_count=$(kubectl get services --all-namespaces --no-headers 2>/dev/null | wc -l)
    echo "   Services: $service_count"
    
    # Get namespace count
    local namespace_count=$(kubectl get namespaces --no-headers 2>/dev/null | wc -l)
    echo "   Namespaces: $namespace_count"
    
    # Check for issues
    local failed_pods=$(kubectl get pods --all-namespaces --no-headers 2>/dev/null | grep -v Running | grep -v Completed | wc -l)
    if [ $failed_pods -gt 0 ]; then
        echo -e "   ${RED}‚ö†Ô∏è  Issues: $failed_pods pods not running${NC}"
    fi
    
    echo "   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    # Restore context
    kubectl config use-context $current_context &>/dev/null
}

# Display system resources
display_system_resources() {
    echo -e "${YELLOW}üíª System Resources:${NC}"
    
    # CPU info
    local cpu_count=$(nproc 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo "Unknown")
    echo "   CPU Cores Available: $cpu_count"
    
    # Memory info (Linux)
    if command -v free &> /dev/null; then
        local mem_info=$(free -h | grep "Mem:")
        echo "   Memory: $mem_info"
    fi
    
    # Disk info
    local disk_usage=$(df -h . | tail -1 | awk '{print $4 " available of " $2}')
    echo "   Disk Space: $disk_usage"
    
    echo "   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
}

# Display profile summary
display_profile_summary() {
    local profiles=($(minikube profile list -o json 2>/dev/null | jq -r '.[].Name' | sort))
    local running_count=0
    local stopped_count=0
    local total_cpu=0
    local total_memory=0
    
    for profile in "${profiles[@]}"; do
        local status=$(minikube status -p $profile --format='{{.Host}}' 2>/dev/null || echo "Unknown")
        if [ "$status" = "Running" ]; then
            running_count=$((running_count + 1))
            local cpu=$(minikube config get cpus -p $profile 2>/dev/null || echo "2")
            local memory=$(minikube config get memory -p $profile 2>/dev/null || echo "4096")
            total_cpu=$((total_cpu + cpu))
            total_memory=$((total_memory + memory))
        else
            stopped_count=$((stopped_count + 1))
        fi
    done
    
    echo -e "${BLUE}üìà Profile Summary:${NC}"
    echo "   Total Profiles: ${#profiles[@]}"
    echo -e "   Running: ${GREEN}$running_count${NC}"
    echo -e "   Stopped: ${RED}$stopped_count${NC}"
    echo "   Total Allocated CPU: ${total_cpu} cores"
    echo "   Total Allocated Memory: ${total_memory}MB ($(echo "scale=2; $total_memory/1024" | bc)GB)"
    echo "   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
}

# Main monitoring function
start_monitoring() {
    local refresh_interval=${1:-10}
    
    while true; do
        display_header
        display_system_resources
        display_profile_summary
        
        # Get all profiles
        local profiles=($(minikube profile list -o json 2>/dev/null | jq -r '.[].Name' | sort))
        
        if [ ${#profiles[@]} -eq 0 ]; then
            echo -e "${RED}‚ùå No minikube profiles found${NC}"
        else
            for profile in "${profiles[@]}"; do
                monitor_profile "$profile"
            done
        fi
        
        echo ""
        echo -e "${YELLOW}üîÑ Refreshing in ${refresh_interval}s... (Ctrl+C to exit)${NC}"
        sleep $refresh_interval
    done
}

# Command line interface
case "$1" in
    "once")
        display_header
        display_system_resources
        display_profile_summary
        profiles=($(minikube profile list -o json 2>/dev/null | jq -r '.[].Name' | sort))
        for profile in "${profiles[@]}"; do
            monitor_profile "$profile"
        done
        ;;
    "watch")
        start_monitoring ${2:-10}
        ;;
    *)
        echo "Usage: $0 {once|watch} [refresh_interval]"
        echo ""
        echo "Commands:"
        echo "  once              - Show current status once"
        echo "  watch [interval]  - Continuously monitor (default: 10s)"
        echo ""
        echo "Examples:"
        echo "  $0 once           - Single status report"
        echo "  $0 watch          - Monitor with 10s refresh"
        echo "  $0 watch 5        - Monitor with 5s refresh"
        ;;
esac
EOF

chmod +x multi-profile-monitor.sh
```

## ‚úÖ Success Criteria

### ‚úÖ Multi-Profile Management Checklist
- [ ] Can create multiple profiles with different configurations
- [ ] Understand profile isolation and resource allocation
- [ ] Master profile switching and context management
- [ ] Can implement environment-specific configurations
- [ ] Automate profile creation and destruction
- [ ] Monitor multiple profiles simultaneously
- [ ] Integrate profiles with CI/CD workflows
- [ ] Troubleshoot profile-specific issues

### ‚úÖ Validation Commands
```bash
# Test all profile operations:
./setup-development-profile.sh
./setup-staging-profile.sh
./setup-testing-profile.sh
./profile-switcher.sh list
./bulk-profile-ops.sh status-all
./multi-profile-monitor.sh once
```

## üéØ Next Steps

After mastering multi-profile management:

1. **Advanced Networking** - Learn cross-profile networking and ingress
2. **Resource Optimization** - Optimize profiles for specific workloads
3. **Integration Testing** - Test applications across multiple environments
4. **GitOps Workflows** - Integrate profiles with GitOps practices
5. **Production Readiness** - Prepare staging profiles for production deployment

## üìö Key Takeaways

### What You've Learned
1. **Profile Architecture**: Creating isolated environments for different purposes
2. **Resource Management**: Optimizing resource allocation across profiles
3. **Automation**: Scripting profile creation, management, and monitoring
4. **CI/CD Integration**: Using profiles in automated testing workflows
5. **Environment Parity**: Maintaining consistency between environments

### Best Practices Implemented
- Environment-specific resource allocation
- Automated profile lifecycle management
- Comprehensive monitoring and resource tracking
- Security-conscious production-like configurations
- CI/CD-ready ephemeral profile creation

Multi-profile management enables sophisticated development workflows and ensures environment consistency across the development lifecycle.